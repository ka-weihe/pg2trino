// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o bundle.go -pkg wire .

package wire

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"maps"
	"net"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jeroenrinzema/psql-wire/codes"
	pgerror "github.com/jeroenrinzema/psql-wire/errors"
	psqlerr "github.com/jeroenrinzema/psql-wire/errors"
	"github.com/jeroenrinzema/psql-wire/pkg/buffer"
	"github.com/jeroenrinzema/psql-wire/pkg/types"
	"github.com/lib/pq/oid"
)

// authType represents the manner in which a client is able to authenticate
type wire_authType int32

const (
	// authOK indicates that the connection has been authenticated and the client
	// is allowed to proceed.
	wire_authOK wire_authType = 0
	// authClearTextPassword is a authentication type used to tell the client to identify
	// itself by sending the password in clear text to the Postgres server.
	wire_authClearTextPassword wire_authType = 3
)

// AuthStrategy represents a authentication strategy used to authenticate a user
type wire_AuthStrategy func(ctx context.Context, writer *buffer.Writer, reader *buffer.Reader) (_ context.Context, err error)

// handleAuth handles the client authentication for the given connection.
// This methods validates the incoming credentials and writes to the client whether
// the provided credentials are correct. When the provided credentials are invalid
// or any unexpected error occures is an error returned and should the connection be closed.
func (srv *wire_Server) handleAuth(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) (context.Context, error) {
	srv.logger.Debug("authenticating client connection")

	if srv.Auth == nil {
		// No authentication strategy configured.
		// Announcing to the client that the connection is authenticated
		return ctx, wire_writeAuthType(writer, wire_authOK)
	}

	return srv.Auth(ctx, writer, reader)
}

// ClearTextPassword announces to the client to authenticate by sending a
// clear text password and validates if the provided username and password (received
// inside the client parameters) are valid. If the provided credentials are invalid
// or any unexpected error occures is an error returned and should the connection be closed.
func wire_ClearTextPassword(validate func(ctx context.Context, username, password string) (context.Context, bool, error)) wire_AuthStrategy {
	return func(ctx context.Context, writer *buffer.Writer, reader *buffer.Reader) (_ context.Context, err error) {
		err = wire_writeAuthType(writer, wire_authClearTextPassword)
		if err != nil {
			return ctx, err
		}

		params := wire_ClientParameters(ctx)
		t, _, err := reader.ReadTypedMsg()
		if err != nil {
			return ctx, err
		}

		if t != types.ClientPassword {
			return ctx, errors.New("unexpected password message")
		}

		password, err := reader.GetString()
		if err != nil {
			return ctx, err
		}

		ctx, valid, err := validate(ctx, params[wire_ParamUsername], password)
		if err != nil {
			return ctx, err
		}

		if !valid {
			return ctx, wire_ErrorCode(writer, pgerror.WithCode(errors.New("invalid username/password"), codes.InvalidPassword))
		}

		return ctx, wire_writeAuthType(writer, wire_authOK)
	}
}

// writeAuthType writes the auth type to the client informing the client about the
// authentication status and the expected data to be received.
func wire_writeAuthType(writer *buffer.Writer, status wire_authType) error {
	writer.Start(types.ServerAuth)
	writer.AddInt32(int32(status))
	return writer.End()
}

// IsSuperUser checks whether the given connection context is a super user
func wire_IsSuperUser(ctx context.Context) bool {
	return false
}

// AuthenticatedUsername returns the username of the authenticated user of the
// given connection context
func wire_AuthenticatedUsername(ctx context.Context) string {
	parameters := wire_ClientParameters(ctx)
	return parameters[wire_ParamUsername]
}

type wire_Statement struct {
	fn         wire_PreparedStatementFn
	parameters []oid.Oid
	columns    wire_Columns
}

type wire_DefaultStatementCache struct {
	statements map[string]*wire_Statement
	mu         sync.RWMutex
}

// Set attempts to bind the given statement to the given name. Any
// previously defined statement is overridden.
func (cache *wire_DefaultStatementCache) Set(ctx context.Context, name string, stmt *wire_PreparedStatement) error {
	cache.mu.Lock()
	defer cache.mu.Unlock()

	if cache.statements == nil {
		cache.statements = map[string]*wire_Statement{}
	}

	cache.statements[name] = &wire_Statement{
		fn:         stmt.fn,
		parameters: stmt.parameters,
		columns:    stmt.columns,
	}

	return nil
}

// Get attempts to get the prepared statement for the given name. An error
// is returned when no statement has been found.
func (cache *wire_DefaultStatementCache) Get(ctx context.Context, name string) (*wire_Statement, error) {
	cache.mu.RLock()
	defer cache.mu.RUnlock()

	if cache.statements == nil {
		return nil, nil
	}

	stmt, has := cache.statements[name]
	if !has {
		return nil, nil
	}

	return stmt, nil
}

type wire_Portal struct {
	statement  *wire_Statement
	parameters []wire_Parameter
	formats    []wire_FormatCode
}

type wire_DefaultPortalCache struct {
	portals map[string]*wire_Portal
	mu      sync.RWMutex
}

func (cache *wire_DefaultPortalCache) Bind(ctx context.Context, name string, stmt *wire_Statement, parameters []wire_Parameter, formats []wire_FormatCode) error {
	cache.mu.Lock()
	defer cache.mu.Unlock()

	if cache.portals == nil {
		cache.portals = map[string]*wire_Portal{}
	}

	cache.portals[name] = &wire_Portal{
		statement:  stmt,
		parameters: parameters,
		formats:    formats,
	}

	return nil
}

func (cache *wire_DefaultPortalCache) Get(ctx context.Context, name string) (*wire_Portal, error) {
	cache.mu.Lock()
	defer cache.mu.Unlock()

	if cache.portals == nil {
		return nil, nil
	}

	portal, has := cache.portals[name]
	if !has {
		return nil, nil
	}

	return portal, nil
}

func (cache *wire_DefaultPortalCache) Execute(ctx context.Context, name string, writer *buffer.Writer) (err error) {
	defer func() {
		r := recover()
		if r != nil {
			err = fmt.Errorf("unexpected panic: %s", r)
		}
	}()

	cache.mu.Lock()
	defer cache.mu.Unlock()

	if cache.portals == nil {
		return nil
	}

	portal, has := cache.portals[name]
	if !has {
		return nil
	}

	err = portal.statement.fn(ctx, wire_NewDataWriter(ctx, portal.statement.columns, portal.formats, writer), portal.parameters)
	if err != nil {
		return err
	}

	return err
}

// NewErrUnimplementedMessageType is called whenever a unimplemented message
// type is send. This error indicates to the client that the send message cannot
// be processed at this moment in time.
func wire_NewErrUnimplementedMessageType(t types.ClientMessage) error {
	err := fmt.Errorf("unimplemented client message type: %d", t)
	return psqlerr.WithSeverity(psqlerr.WithCode(err, codes.ConnectionDoesNotExist), psqlerr.LevelFatal)
}

// NewErrUnkownStatement is returned whenever no executable has been found for
// the given name.
func wire_NewErrUnkownStatement(name string) error {
	err := fmt.Errorf("unknown executeable: %s", name)
	return psqlerr.WithSeverity(psqlerr.WithCode(err, codes.InvalidPreparedStatementDefinition), psqlerr.LevelFatal)
}

// NewErrUndefinedStatement is returned whenever no statement has been defined
// within the incoming query.
func wire_NewErrUndefinedStatement() error {
	err := errors.New("no statement has been defined")
	return psqlerr.WithSeverity(psqlerr.WithCode(err, codes.Syntax), psqlerr.LevelError)
}

// NewErrMultipleCommandsStatements is returned whenever multiple statements have been
// given within a single query during the extended query protocol.
func wire_NewErrMultipleCommandsStatements() error {
	err := errors.New("cannot insert multiple commands into a prepared statement")
	return psqlerr.WithSeverity(psqlerr.WithCode(err, codes.Syntax), psqlerr.LevelError)
}

// consumeCommands consumes incoming commands send over the Postgres wire connection.
// Commands consumed from the connection are returned through a go channel.
// Responses for the given message type are written back to the client.
// This method keeps consuming messages until the client issues a close message
// or the connection is terminated.
func (srv *wire_Server) consumeCommands(ctx context.Context, conn net.Conn, reader *buffer.Reader, writer *buffer.Writer) (err error) {
	srv.logger.Debug("ready for query... starting to consume commands")

	// TODO: Include a value to identify unique connections
	//
	// include a identification value inside the context that
	// could be used to identify connections at a later stage.

	err = wire_readyForQuery(writer, types.ServerIdle)
	if err != nil {
		return err
	}

	for {
		t, length, err := reader.ReadTypedMsg()
		if err == io.EOF {
			return nil
		}

		// NOTE: we could recover from this scenario
		if errors.Is(err, buffer.ErrMessageSizeExceeded) {
			err = srv.handleMessageSizeExceeded(reader, writer, err)
			if err != nil {
				return err
			}

			continue
		}

		if err != nil {
			return err
		}

		if srv.closing.Load() {
			return nil
		}

		// NOTE: we increase the wait group by one in order to make sure that idle
		// connections are not blocking a close.
		srv.wg.Add(1)
		srv.logger.Debug("incoming command", slog.Int("length", length), slog.String("type", string(t)))
		err = srv.handleCommand(ctx, conn, t, reader, writer)
		srv.wg.Done()
		if errors.Is(err, io.EOF) {
			return nil
		}

		if err != nil {
			return err
		}
	}
}

// handleMessageSizeExceeded attempts to unwrap the given error message as
// message size exceeded. The expected message size will be consumed and
// discarded from the given reader. An error message is written to the client
// once the expected message size is read.
//
// The given error is returned if it does not contain an message size exceeded
// type. A fatal error is returned when an unexpected error is returned while
// consuming the expected message size or when attempting to write the error
// message back to the client.
func (srv *wire_Server) handleMessageSizeExceeded(reader *buffer.Reader, writer *buffer.Writer, exceeded error) (err error) {
	unwrapped, has := buffer.UnwrapMessageSizeExceeded(exceeded)
	if !has {
		return exceeded
	}

	err = reader.Slurp(unwrapped.Size)
	if err != nil {
		return err
	}

	return wire_ErrorCode(writer, exceeded)
}

// handleCommand handles the given client message. A client message includes a
// message type and reader buffer containing the actual message. The type
// indecates a action executed by the client.
// https://www.postgresql.org/docs/14/protocol-message-formats.html
func (srv *wire_Server) handleCommand(ctx context.Context, conn net.Conn, t types.ClientMessage, reader *buffer.Reader, writer *buffer.Writer) (err error) {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	switch t {
	case types.ClientSimpleQuery:
		return srv.handleSimpleQuery(ctx, reader, writer)
	case types.ClientExecute:
		return srv.handleExecute(ctx, reader, writer)
	case types.ClientParse:
		return srv.handleParse(ctx, reader, writer)
	case types.ClientDescribe:
		// The Describe message (portal variant) specifies the name of an
		// existing portal (or an empty string for the unnamed portal). The
		// response is a RowDescription message describing the rows that will be
		// returned by executing the portal; or a NoData message if the portal
		// does not contain a query that will return rows; or ErrorResponse if
		// there is no such portal.
		//
		// The Describe message (statement variant) specifies the name of an
		// existing prepared statement (or an empty string for the unnamed
		// prepared statement). The response is a ParameterDescription message
		// describing the parameters needed by the statement, followed by a
		// RowDescription message describing the rows that will be returned when
		// the statement is eventually executed (or a NoData message if the
		// statement will not return rows). ErrorResponse is issued if there is
		// no such prepared statement. Note that since Bind has not yet been
		// issued, the formats to be used for returned columns are not yet known
		// to the backend; the format code fields in the RowDescription message
		// will be zeroes in this case.
		// https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
		return srv.handleDescribe(ctx, reader, writer)
	case types.ClientSync:
		// TODO: Include the ability to catch sync messages in order to
		// close the current transaction.
		//
		// At completion of each series of extended-query messages, the frontend
		// should issue a Sync message. This parameterless message causes the
		// backend to close the current transaction if it's not inside a
		// BEGIN/COMMIT transaction block (“close” meaning to commit if no
		// error, or roll back if error). Then a ReadyForQuery response is
		// issued. The purpose of Sync is to provide a resynchronization point
		// for error recovery. When an error is detected while processing any
		// extended-query message, the backend issues ErrorResponse, then reads
		// and discards messages until a Sync is reached, then issues
		// ReadyForQuery and returns to normal message processing. (But note
		// that no skipping occurs if an error is detected while processing Sync
		// — this ensures that there is one and only one ReadyForQuery sent for
		// each Sync.)
		// https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
		return wire_readyForQuery(writer, types.ServerIdle)
	case types.ClientBind:
		return srv.handleBind(ctx, reader, writer)
	case types.ClientFlush:
		// TODO: Flush all remaining rows inside connection buffer if
		// any are remaining.
		//
		// The Flush message does not cause any specific
		// output to be generated, but forces the backend to deliver any data
		// pending in its output buffers. A Flush must be sent after any
		// extended-query command except Sync, if the frontend wishes to examine
		// the results of that command before issuing more commands. Without
		// Flush, messages returned by the backend will be combined into the
		// minimum possible number of packets to minimize network overhead.
		// https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
		return nil
	case types.ClientCopyData, types.ClientCopyDone, types.ClientCopyFail:
		// We're supposed to ignore these messages, per the protocol spec. This
		// state will happen when an error occurs on the server-side during a copy
		// operation: the server will send an error and a ready message back to
		// the client, and must then ignore further copy messages. See:
		// https://github.com/postgres/postgres/blob/6e1dd2773eb60a6ab87b27b8d9391b756e904ac3/src/backend/tcop/postgres.c#L4295
		return nil
	case types.ClientClose:
		// TODO: close the statement or portal
		writer.Start(types.ServerCloseComplete) //nolint:errcheck
		writer.End()                            //nolint:errcheck
		return nil
	case types.ClientTerminate:
		err = srv.handleConnTerminate(ctx)
		if err != nil {
			return err
		}

		err = conn.Close()
		if err != nil {
			return err
		}

		return io.EOF
	default:
		return wire_ErrorCode(writer, wire_NewErrUnimplementedMessageType(t))
	}
}

func (srv *wire_Server) handleSimpleQuery(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) error {
	if srv.parse == nil {
		return wire_ErrorCode(writer, wire_NewErrUnimplementedMessageType(types.ClientSimpleQuery))
	}

	query, err := reader.GetString()
	if err != nil {
		return err
	}

	srv.logger.Debug("incoming simple query", slog.String("query", query))

	// NOTE: If a completely empty (no contents other than whitespace) query
	// string is received, the response is EmptyQueryResponse followed by
	// ReadyForQuery.
	// https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
	if strings.TrimSpace(query) == "" {
		writer.Start(types.ServerEmptyQuery)
		err = writer.End()
		if err != nil {
			return err
		}

		return wire_readyForQuery(writer, types.ServerIdle)
	}

	statements, err := srv.parse(ctx, query)
	if err != nil {
		return wire_ErrorCode(writer, err)
	}

	if len(statements) == 0 {
		return wire_ErrorCode(writer, wire_NewErrUndefinedStatement())
	}

	// NOTE: it is possible to send multiple statements in one simple query.
	for index := range statements {
		err = statements[index].columns.Define(ctx, writer, nil)
		if err != nil {
			return wire_ErrorCode(writer, err)
		}

		err = statements[index].fn(ctx, wire_NewDataWriter(ctx, statements[index].columns, nil, writer), nil)
		if err != nil {
			return wire_ErrorCode(writer, err)
		}
	}

	return wire_readyForQuery(writer, types.ServerIdle)
}

func (srv *wire_Server) handleParse(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) error {
	if srv.parse == nil || srv.Statements == nil {
		return wire_ErrorCode(writer, wire_NewErrUnimplementedMessageType(types.ClientParse))
	}

	name, err := reader.GetString()
	if err != nil {
		return err
	}

	query, err := reader.GetString()
	if err != nil {
		return err
	}

	// NOTE: the number of parameter data types specified (can be
	// zero). Note that this is not an indication of the number of parameters
	// that might appear in the query string, only the number that the frontend
	// wants to prespecify types for.
	parameters, err := reader.GetUint16()
	if err != nil {
		return err
	}

	srv.logger.Debug("predefined parameters", slog.Int("parameters", int(parameters)))

	for i := uint16(0); i < parameters; i++ {
		// TODO: Specifies the object ID of the parameter data type
		//
		// Specifies the object ID of the parameter data type. Placing a zero here
		// is equivalent to leaving the type unspecified.
		// `reader.GetUint32()`
	}

	statement, err := wire_singleStatement(srv.parse(ctx, query))
	if err != nil {
		return wire_ErrorCode(writer, err)
	}

	srv.logger.Debug("incoming extended query", slog.String("query", query), slog.String("name", name), slog.Int("parameters", len(statement.parameters)))

	err = srv.Statements.Set(ctx, name, statement)
	if err != nil {
		return wire_ErrorCode(writer, err)
	}

	writer.Start(types.ServerParseComplete)
	return writer.End()
}

func (srv *wire_Server) handleDescribe(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) error {
	d, err := reader.GetBytes(1)
	if err != nil {
		return err
	}

	name, err := reader.GetString()
	if err != nil {
		return err
	}

	switch d[0] {
	case 'S':
		statement, err := srv.Statements.Get(ctx, name)
		if err != nil {
			return err
		}

		if statement == nil {
			return wire_ErrorCode(writer, errors.New("unknown statement"))
		}

		err = srv.writeParameterDescription(writer, statement.parameters)
		if err != nil {
			return err
		}

		// NOTE: the format codes are not yet known at this point in time.
		return srv.writeColumnDescription(ctx, writer, nil, statement.columns)
	case 'P':
		portal, err := srv.Portals.Get(ctx, name)
		if err != nil {
			return err
		}

		if portal == nil {
			return wire_ErrorCode(writer, errors.New("unknown portal"))
		}

		return srv.writeColumnDescription(ctx, writer, portal.formats, portal.statement.columns)
	}

	return wire_ErrorCode(writer, fmt.Errorf("unknown describe command: %s", string(d[0])))
}

// https://www.postgresql.org/docs/15/protocol-message-formats.html
func (srv *wire_Server) writeParameterDescription(writer *buffer.Writer, parameters []oid.Oid) error {
	writer.Start(types.ServerParameterDescription)
	writer.AddInt16(int16(len(parameters)))

	for _, parameter := range parameters {
		writer.AddInt32(int32(parameter))
	}

	return writer.End()
}

// writeColumnDescription attempts to write the statement column descriptions
// back to the writer buffer. Information about the returned columns is written
// to the client.
// https://www.postgresql.org/docs/15/protocol-message-formats.html
func (srv *wire_Server) writeColumnDescription(ctx context.Context, writer *buffer.Writer, formats []wire_FormatCode, columns wire_Columns) error {
	if len(columns) == 0 {
		writer.Start(types.ServerNoData)
		return writer.End()
	}

	return columns.Define(ctx, writer, formats)
}

func (srv *wire_Server) handleBind(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) error {
	name, err := reader.GetString()
	if err != nil {
		return err
	}

	statement, err := reader.GetString()
	if err != nil {
		return err
	}

	parameters, err := srv.readParameters(ctx, reader)
	if err != nil {
		return err
	}

	formats, err := srv.readColumnTypes(ctx, reader)
	if err != nil {
		return err
	}

	stmt, err := srv.Statements.Get(ctx, statement)
	if err != nil {
		return err
	}

	if stmt == nil {
		return wire_NewErrUnkownStatement(statement)
	}

	err = srv.Portals.Bind(ctx, name, stmt, parameters, formats)
	if err != nil {
		return err
	}

	writer.Start(types.ServerBindComplete)
	return writer.End()
}

// readParameters attempts to read all incoming parameters from the given
// reader. The parameters are parsed and returned.
// https://www.postgresql.org/docs/14/protocol-message-formats.html
func (srv *wire_Server) readParameters(ctx context.Context, reader *buffer.Reader) ([]wire_Parameter, error) {
	// NOTE: read the total amount of parameter format length that will be send
	// by the client. This can be zero to indicate that there are no parameters
	// or that the parameters all use the default format (text); or one, in
	// which case the specified format code is applied to all parameters; or it
	// can equal the actual number of parameters.
	length, err := reader.GetUint16()
	if err != nil {
		return nil, err
	}

	srv.logger.Debug("reading parameters format codes", slog.Uint64("length", uint64(length)))

	defaultFormat := wire_TextFormat
	formats := make([]wire_FormatCode, length)
	for i := uint16(0); i < length; i++ {
		format, err := reader.GetUint16()
		if err != nil {
			return nil, err
		}

		// NOTE: we have to set the default format code to the given format code
		// if only one is given according to the protocol specs. The for loop
		// should not be aborted since the formats slice is buffered.
		if length == 1 {
			defaultFormat = wire_FormatCode(format)
		}

		formats[i] = wire_FormatCode(format)
	}

	// NOTE: read the total amount of parameter values that will be send
	// by the client.
	length, err = reader.GetUint16()
	if err != nil {
		return nil, err
	}

	srv.logger.Debug("reading parameters values", slog.Uint64("length", uint64(length)))

	parameters := make([]wire_Parameter, length)
	for i := 0; i < int(length); i++ {
		length, err := reader.GetUint32()
		if err != nil {
			return nil, err
		}

		value, err := reader.GetBytes(int(length))
		if err != nil {
			return nil, err
		}

		srv.logger.Debug("incoming parameter", slog.String("value", string(value)))

		format := defaultFormat
		if len(formats) > int(i) {
			format = formats[i]
		}

		parameters[i] = wire_NewParameter(wire_TypeMap(ctx), format, value)
	}

	return parameters, nil
}

func (srv *wire_Server) readColumnTypes(ctx context.Context, reader *buffer.Reader) ([]wire_FormatCode, error) {
	length, err := reader.GetUint16()
	if err != nil {
		return nil, err
	}

	srv.logger.Debug("reading column format codes", slog.Uint64("length", uint64(length)))

	columns := make([]wire_FormatCode, length)
	for i := uint16(0); i < length; i++ {
		format, err := reader.GetUint16()
		if err != nil {
			return nil, err
		}

		columns[i] = wire_FormatCode(format)
	}

	return columns, nil
}

func (srv *wire_Server) handleExecute(ctx context.Context, reader *buffer.Reader, writer *buffer.Writer) error {
	if srv.Statements == nil {
		return wire_ErrorCode(writer, wire_NewErrUnimplementedMessageType(types.ClientExecute))
	}

	name, err := reader.GetString()
	if err != nil {
		return err
	}

	// TODO: Limit the maximum number of records to be returned.
	//
	// Maximum number of limit to return, if portal contains a
	// query that returns limit (ignored otherwise). Zero denotes “no limit”.
	limit, err := reader.GetUint32()
	if err != nil {
		return err
	}

	srv.logger.Debug("executing", slog.String("name", name), slog.Uint64("limit", uint64(limit)))
	err = srv.Portals.Execute(ctx, name, writer)
	if err != nil {
		return wire_ErrorCode(writer, err)
	}

	return nil
}

func (srv *wire_Server) handleConnTerminate(ctx context.Context) error {
	if srv.TerminateConn == nil {
		return nil
	}

	return srv.TerminateConn(ctx)
}

func wire_singleStatement(stmts wire_PreparedStatements, err error) (*wire_PreparedStatement, error) {
	if err != nil {
		return nil, err
	}

	if len(stmts) > 1 {
		return nil, wire_NewErrMultipleCommandsStatements()
	}

	if len(stmts) == 0 {
		return nil, wire_NewErrUndefinedStatement()
	}

	return stmts[0], nil
}

type wire_ctxKey int

const (
	wire_ctxTypeMap wire_ctxKey = iota
	wire_ctxClientMetadata
	wire_ctxServerMetadata
)

// setTypeInfo constructs a new Postgres type connection info for the given value
func wire_setTypeInfo(ctx context.Context, info *pgtype.Map) context.Context {
	return context.WithValue(ctx, wire_ctxTypeMap, info)
}

// TypeMap returns the Postgres type connection info if it has been set inside
// the given context.
func wire_TypeMap(ctx context.Context) *pgtype.Map {
	val := ctx.Value(wire_ctxTypeMap)
	if val == nil {
		return nil
	}

	return val.(*pgtype.Map)
}

// Parameters represents a parameters collection of parameter status keys and
// their values
type wire_Parameters map[wire_ParameterStatus]string

// ParameterStatus represents a metadata key that could be defined inside a server/client
// metadata definition
type wire_ParameterStatus string

// At present there is a hard-wired set of parameters for which ParameterStatus
// will be generated.
// https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-ASYNC
const (
	wire_ParamServerEncoding       wire_ParameterStatus = "server_encoding"
	wire_ParamClientEncoding       wire_ParameterStatus = "client_encoding"
	wire_ParamIsSuperuser          wire_ParameterStatus = "is_superuser"
	wire_ParamSessionAuthorization wire_ParameterStatus = "session_authorization"
	wire_ParamApplicationName      wire_ParameterStatus = "application_name"
	wire_ParamDatabase             wire_ParameterStatus = "database"
	wire_ParamUsername             wire_ParameterStatus = "user"
	wire_ParamServerVersion        wire_ParameterStatus = "server_version"
)

// setClientParameters constructs a new context containing the given parameters.
// Any previously defined metadata will be overriden.
func wire_setClientParameters(ctx context.Context, params wire_Parameters) context.Context {
	if params == nil {
		return ctx
	}

	return context.WithValue(ctx, wire_ctxClientMetadata, params)
}

// ClientParameters returns the connection parameters if it has been set inside
// the given context.
func wire_ClientParameters(ctx context.Context) wire_Parameters {
	val := ctx.Value(wire_ctxClientMetadata)
	if val == nil {
		return nil
	}

	return val.(wire_Parameters)
}

// setServerParameters constructs a new context containing the given parameters map.
// Any previously defined metadata will be overriden.
func wire_setServerParameters(ctx context.Context, params wire_Parameters) context.Context {
	if params == nil {
		return ctx
	}

	return context.WithValue(ctx, wire_ctxServerMetadata, params)
}

// ServerParameters returns the connection parameters if it has been set inside
// the given context.
func wire_ServerParameters(ctx context.Context) wire_Parameters {
	val := ctx.Value(wire_ctxServerMetadata)
	if val == nil {
		return nil
	}

	return val.(wire_Parameters)
}

// errFieldType represents the error fields.
type wire_errFieldType byte

// http://www.postgresql.org/docs/current/static/protocol-error-fields.html
//
//nolint:varcheck,deadcode
const (
	wire_errFieldSeverity       wire_errFieldType = 'S'
	wire_errFieldMsgPrimary     wire_errFieldType = 'M'
	wire_errFieldSQLState       wire_errFieldType = 'C'
	wire_errFieldDetail         wire_errFieldType = 'D'
	wire_errFieldHint           wire_errFieldType = 'H'
	wire_errFieldSrcFile        wire_errFieldType = 'F'
	wire_errFieldSrcLine        wire_errFieldType = 'L'
	wire_errFieldSrcFunction    wire_errFieldType = 'R'
	wire_errFieldConstraintName wire_errFieldType = 'n'
)

// ErrorCode writes a error message as response to a command with the given
// severity and error message. A ready for query message is written back to the
// client once the error has been written indicating the end of a command cycle.
// https://www.postgresql.org/docs/current/static/protocol-error-fields.html
func wire_ErrorCode(writer *buffer.Writer, err error) error {
	desc := psqlerr.Flatten(err)

	writer.Start(types.ServerErrorResponse)

	writer.AddByte(byte(wire_errFieldSeverity))
	writer.AddString(string(desc.Severity))
	writer.AddNullTerminate()
	writer.AddByte(byte(wire_errFieldSQLState))
	writer.AddString(string(desc.Code))
	writer.AddNullTerminate()
	writer.AddByte(byte(wire_errFieldMsgPrimary))
	writer.AddString(desc.Message)
	writer.AddNullTerminate()

	if desc.Hint != "" {
		writer.AddByte(byte(wire_errFieldHint))
		writer.AddString(desc.Hint)
		writer.AddNullTerminate()
	}

	if desc.Detail != "" {
		writer.AddByte(byte(wire_errFieldDetail))
		writer.AddString(desc.Detail)
		writer.AddNullTerminate()
	}

	if desc.Source != nil {
		writer.AddByte(byte(wire_errFieldSrcFile))
		writer.AddString(desc.Source.File)
		writer.AddNullTerminate()

		writer.AddByte(byte(wire_errFieldSrcLine))
		writer.AddInt32(desc.Source.Line)
		writer.AddNullTerminate()

		writer.AddByte(byte(wire_errFieldSrcFunction))
		writer.AddString(desc.Source.Function)
		writer.AddNullTerminate()
	}

	writer.AddNullTerminate()
	err = writer.End()
	if err != nil {
		return err
	}

	// NOTE: we are writing a ready for query message to indicate the end of a
	// command cycle.
	return wire_readyForQuery(writer, types.ServerIdle)
}

// FormatCode represents the encoding format of a given column
type wire_FormatCode int16

const (
	// TextFormat is the default, text format.
	wire_TextFormat wire_FormatCode = 0
	// BinaryFormat is an alternative, binary, encoding.
	wire_BinaryFormat wire_FormatCode = 1
)

// Handshake performs the connection handshake and returns the connection
// version and a buffered reader to read incoming messages send by the client.
func (srv *wire_Server) Handshake(conn net.Conn) (_ net.Conn, version types.Version, reader *buffer.Reader, err error) {
	reader = buffer.NewReader(srv.logger, conn, srv.BufferedMsgSize)
	version, err = srv.readVersion(reader)
	if err != nil {
		return conn, version, reader, err
	}

	if version == types.VersionCancel {
		return conn, version, reader, nil
	}

	// TODO: support GSS encryption
	//
	// `psql-wire` currently does not support GSS encrypted connections. The GSS
	// authentication API is supported inside the PostgreSQL wire protocol and
	// API's should be made available to support these type of connections.
	// https://www.postgresql.org/docs/current/gssapi-auth.html
	// https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.6.7.13

	conn, reader, version, err = srv.potentialConnUpgrade(conn, reader, version)
	if err != nil {
		return conn, version, reader, err
	}

	return conn, version, reader, nil
}

// readVersion reads the start-up protocol version (uint32) and the
// buffer containing the rest.
func (srv *wire_Server) readVersion(reader *buffer.Reader) (_ types.Version, err error) {
	var version uint32
	_, err = reader.ReadUntypedMsg()
	if err != nil {
		return 0, err
	}

	version, err = reader.GetUint32()
	if err != nil {
		return 0, err
	}

	return types.Version(version), nil
}

// readyForQuery indicates that the server is ready to receive queries.
// The given server status is included inside the message to indicate the server
// status. This message should be written when a command cycle has been completed.
func wire_readyForQuery(writer *buffer.Writer, status types.ServerStatus) error {
	writer.Start(types.ServerReady)
	writer.AddByte(byte(status))
	return writer.End()
}

// readParameters reads the key/value connection parameters send by the client and
// The read parameters will be set inside the given context. A new context containing
// the consumed parameters will be returned.
func (srv *wire_Server) readClientParameters(ctx context.Context, reader *buffer.Reader) (_ context.Context, err error) {
	meta := make(wire_Parameters)

	srv.logger.Debug("reading client parameters")

	for {
		key, err := reader.GetString()
		if err != nil {
			return nil, err
		}

		// an empty key indicates the end of the connection parameters
		if len(key) == 0 {
			break
		}

		value, err := reader.GetString()
		if err != nil {
			return nil, err
		}

		srv.logger.Debug("client parameter", slog.String("key", key), slog.String("value", value))
		meta[wire_ParameterStatus(key)] = value
	}

	return wire_setClientParameters(ctx, meta), nil
}

// writeParameters writes the server parameters such as client encoding to the client.
// The written parameters will be attached as a value to the given context. A new
// context containing the written parameters will be returned.
// https://www.postgresql.org/docs/10/libpq-status.html
func (srv *wire_Server) writeParameters(ctx context.Context, writer *buffer.Writer, params wire_Parameters) (_ context.Context, err error) {
	if params == nil {
		params = make(wire_Parameters, 4)
	} else {
		params = maps.Clone(params)
	}

	srv.logger.Debug("writing server parameters")

	params[wire_ParamServerEncoding] = "UTF8"
	params[wire_ParamClientEncoding] = "UTF8"
	if srv.Version != "" {
		params[wire_ParamServerVersion] = srv.Version
	}
	params[wire_ParamIsSuperuser] = buffer.EncodeBoolean(wire_IsSuperUser(ctx))
	params[wire_ParamSessionAuthorization] = wire_AuthenticatedUsername(ctx)

	for key, value := range params {
		srv.logger.Debug("server parameter", slog.String("key", string(key)), slog.String("value", value))

		writer.Start(types.ServerParameterStatus)
		writer.AddString(string(key))
		writer.AddNullTerminate()
		writer.AddString(value)
		writer.AddNullTerminate()
		err = writer.End()
		if err != nil {
			return ctx, err
		}
	}

	return wire_setServerParameters(ctx, params), nil
}

// potentialConnUpgrade potentially upgrades the given connection using TLS
// if the client requests for it. The connection upgrade is ignored if the
// server does not support a secure connection.
func (srv *wire_Server) potentialConnUpgrade(conn net.Conn, reader *buffer.Reader, version types.Version) (_ net.Conn, _ *buffer.Reader, _ types.Version, err error) {
	if version != types.VersionSSLRequest {
		return conn, reader, version, nil
	}

	srv.logger.Debug("attempting to upgrade the client to a TLS connection")

	if len(srv.Certificates) == 0 {
		srv.logger.Debug("no TLS certificates available continuing with a insecure connection")
		return srv.sslUnsupported(conn, reader, version)
	}

	_, err = conn.Write(wire_sslSupported)
	if err != nil {
		return conn, reader, version, err
	}

	tlsConfig := tls.Config{
		Certificates: srv.Certificates,
		ClientAuth:   srv.ClientAuth,
		ClientCAs:    srv.ClientCAs,
	}

	// NOTE: initialize the TLS connection and construct a new buffered
	// reader for the constructed TLS connection.
	conn = tls.Server(conn, &tlsConfig)
	reader = buffer.NewReader(srv.logger, conn, srv.BufferedMsgSize)

	version, err = srv.readVersion(reader)
	if err != nil {
		return conn, reader, version, err
	}

	srv.logger.Debug("connection has been upgraded successfully")
	return conn, reader, version, err
}

// sslUnsupported announces to the PostgreSQL client that we are unable to
// upgrade the connection to a secure connection at this time. The client
// version is read again once the insecure connection has been announced.
func (srv *wire_Server) sslUnsupported(conn net.Conn, reader *buffer.Reader, version types.Version) (_ net.Conn, _ *buffer.Reader, _ types.Version, err error) {
	_, err = conn.Write(wire_sslUnsupported)
	if err != nil {
		return conn, reader, version, err
	}

	version, err = srv.readVersion(reader)
	if err != nil {
		return conn, reader, version, err
	}

	if version == types.VersionCancel {
		return conn, reader, version, errors.New("unexpected cancel version after upgrading the client connection")
	}

	return conn, reader, version, nil
}

// ParseFn parses the given query and returns a prepared statement which could
// be used to execute at a later point in time.
type wire_ParseFn func(ctx context.Context, query string) (wire_PreparedStatements, error)

// PreparedStatementFn represents a query of which a statement has been
// prepared. The statement could be executed at any point in time with the given
// arguments and data writer.
type wire_PreparedStatementFn func(ctx context.Context, writer wire_DataWriter, parameters []wire_Parameter) error

// Prepared is a small wrapper function returning a list of prepared statements.
// More then one prepared statement could be returned within the simple query
// protocol. An error is returned when more then one prepared statement is
// returned in the extended query protocol.
// https://www.postgresql.org/docs/15/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT
func wire_Prepared(stmts ...*wire_PreparedStatement) wire_PreparedStatements {
	return stmts
}

// NewStatement constructs a new prepared statement for the given function.
func wire_NewStatement(fn wire_PreparedStatementFn, options ...wire_PreparedOptionFn) *wire_PreparedStatement {
	stmt := &wire_PreparedStatement{
		fn: fn,
	}

	for _, option := range options {
		option(stmt)
	}

	return stmt
}

// PreparedOptionFn options pattern used to define options while preparing a new statement.
type wire_PreparedOptionFn func(*wire_PreparedStatement)

// WithColumns sets the given columns as the columns which are returned by the
// prepared statement.
func wire_WithColumns(columns wire_Columns) wire_PreparedOptionFn {
	return func(stmt *wire_PreparedStatement) {
		stmt.columns = columns
	}
}

// WithParameters sets the given parameters as the parameters which are expected
// by the prepared statement.
func wire_WithParameters(parameters []oid.Oid) wire_PreparedOptionFn {
	return func(stmt *wire_PreparedStatement) {
		stmt.parameters = parameters
	}
}

type wire_PreparedStatements []*wire_PreparedStatement

type wire_PreparedStatement struct {
	fn         wire_PreparedStatementFn
	parameters []oid.Oid
	columns    wire_Columns
}

// SessionHandler represents a wrapper function defining the state of a single
// session. This function allows the user to wrap additional metadata around the
// shared context.
type wire_SessionHandler func(ctx context.Context) (context.Context, error)

// StatementCache represents a cache which could be used to store and retrieve
// prepared statements bound to a name.
type wire_StatementCache interface {
	// Set attempts to bind the given statement to the given name. Any
	// previously defined statement is overridden.
	Set(ctx context.Context, name string, fn *wire_PreparedStatement) error
	// Get attempts to get the prepared statement for the given name. An error
	// is returned when no statement has been found.
	Get(ctx context.Context, name string) (*wire_Statement, error)
}

// PortalCache represents a cache which could be used to bind and execute
// prepared statements with parameters.
type wire_PortalCache interface {
	Bind(ctx context.Context, name string, statement *wire_Statement, parameters []wire_Parameter, columns []wire_FormatCode) error
	Get(ctx context.Context, name string) (*wire_Portal, error)
	Execute(ctx context.Context, name string, writer *buffer.Writer) error
}

type wire_CloseFn func(ctx context.Context) error

// OptionFn options pattern used to define and set options for the given
// PostgreSQL server.
type wire_OptionFn func(*wire_Server) error

// Statements sets the statement cache used to cache statements for later use. By
// default is the DefaultStatementCache used to cache prepared statements.
func wire_Statements(cache wire_StatementCache) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Statements = cache
		return nil
	}
}

// Portals sets the portals cache used to cache statements for later use. By
// default is the DefaultPortalCache used to evaluate portals.
func wire_Portals(cache wire_PortalCache) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Portals = cache
		return nil
	}
}

// CloseConn sets the close connection handle inside the given server instance.
func wire_CloseConn(fn wire_CloseFn) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.CloseConn = fn
		return nil
	}
}

// TerminateConn sets the terminate connection handle inside the given server instance.
func wire_TerminateConn(fn wire_CloseFn) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.TerminateConn = fn
		return nil
	}
}

// MessageBufferSize sets the message buffer size which is allocated once a new
// connection gets constructed. If a negative value or zero value is provided is
// the default message buffer size used.
func wire_MessageBufferSize(size int) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.BufferedMsgSize = size
		return nil
	}
}

// Certificates sets the given TLS certificates to be used to initialize a
// secure connection between the front-end (client) and back-end (server).
func wire_Certificates(certs []tls.Certificate) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Certificates = certs
		return nil
	}
}

// ClientCAs sets the given Client CAs to be used, by the server, to verify a
// secure connection between the front-end (client) and back-end (server).
func wire_ClientCAs(cas *x509.CertPool) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.ClientCAs = cas
		return nil
	}
}

// ClientAuth sets the given Client Auth to be used, by the server, to verify a
// secure connection between the front-end (client) and back-end (server).
func wire_ClientAuth(authType tls.ClientAuthType) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.ClientAuth = authType
		return nil
	}
}

// SessionAuthStrategy sets the given authentication strategy within the given
// server. The authentication strategy is called when a handshake is initiated.
func wire_SessionAuthStrategy(fn wire_AuthStrategy) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Auth = fn
		return nil
	}
}

// GlobalParameters sets the server parameters which are send back to the
// front-end (client) once a handshake has been established.
func wire_GlobalParameters(params wire_Parameters) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Parameters = params
		return nil
	}
}

// Logger sets the given zap logger as the default logger for the given server.
func wire_Logger(logger *slog.Logger) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.logger = logger
		return nil
	}
}

// Version sets the PostgreSQL version for the server which is send back to the
// front-end (client) once a handshake has been established.
func wire_Version(version string) wire_OptionFn {
	return func(srv *wire_Server) error {
		srv.Version = version
		return nil
	}
}

// ExtendTypes provides the ability to extend the underlying connection types.
// Types registered inside the given pgtype.ConnInfo are registered to all
// incoming connections.
func wire_ExtendTypes(fn func(*pgtype.Map)) wire_OptionFn {
	return func(srv *wire_Server) error {
		fn(srv.types)
		return nil
	}
}

// Session sets the given session handler within the underlying server. The
// session handler is called when a new connection is opened and authenticated
// allowing for additional metadata to be wrapped around the connection context.
func wire_Session(fn wire_SessionHandler) wire_OptionFn {
	return func(srv *wire_Server) error {
		if srv.Session == nil {
			srv.Session = fn
			return nil
		}

		wrapper := func(parent wire_SessionHandler) wire_SessionHandler {
			return func(ctx context.Context) (context.Context, error) {
				ctx, err := parent(ctx)
				if err != nil {
					return ctx, err
				}

				return fn(ctx)
			}
		}

		srv.Session = wrapper(srv.Session)
		return nil
	}
}

// QueryParameters represents a regex which could be used to identify and lookup
// parameters defined inside a given query. Parameters could be defined as
// positional parameters and un-positional parameters.
// https://www.postgresql.org/docs/15/sql-expressions.html#SQL-EXPRESSIONS-PARAMETERS-POSITIONAL
var wire_QueryParameters = regexp.MustCompile(`\$(\d+)|\?`)

// ParseParameters attempts ot parse the parameters in the given string and
// returns the expected parameters. This is necessary for the query protocol
// where the parameter types are expected to be defined in the extended query protocol.
func wire_ParseParameters(query string) []oid.Oid {
	// NOTE: we have to lookup all parameters within the given query.
	// Parameters could represent positional parameters or anonymous
	// parameters. We return a zero parameter oid for each parameter
	// indicating that the given parameters could contain any type. We
	// could safely ignore the err check while converting given
	// parameters since ony matches are returned by the positional
	// parameter regex.
	matches := wire_QueryParameters.FindAllStringSubmatch(query, -1)
	parameters := make([]oid.Oid, 0, len(matches))
	for _, match := range matches {
		// NOTE: we have to check whether the returned match is a
		// positional parameter or an un-positional parameter.
		// SELECT * FROM users WHERE id = ?
		if match[1] == "" {
			parameters = append(parameters, 0)
		}

		position, _ := strconv.Atoi(match[1]) //nolint:errcheck
		if position > len(parameters) {
			parameters = parameters[:position]
		}
	}

	return parameters
}

var wire_ErrUnknownOid = errors.New("unknown oid")

func wire_NewParameter(types *pgtype.Map, format wire_FormatCode, value []byte) wire_Parameter {
	return wire_Parameter{
		types:  types,
		format: format,
		value:  value,
	}
}

type wire_Parameter struct {
	types  *pgtype.Map
	format wire_FormatCode
	value  []byte
}

func (p wire_Parameter) Scan(oid uint32) (any, error) {
	typed, has := p.types.TypeForOID(oid)
	if !has {
		return nil, wire_ErrUnknownOid
	}

	return typed.Codec.DecodeValue(p.types, oid, int16(p.format), p.value)
}

func (p wire_Parameter) Format() wire_FormatCode {
	return p.format
}

func (p wire_Parameter) Value() []byte {
	return p.value
}

// Columns represent a collection of columns
type wire_Columns []wire_Column

// Define writes the table RowDescription headers for the given table and the
// containing columns. The headers have to be written before any data rows could
// be send back to the client. The given columns are encoded using the given
// format codes. Columns could be encoded as Text or Binary. If you provide a
// single format code, it will be applied to all columns.

// Define writes the table RowDescription headers for the given table and the
// containing columns. The headers have to be written before any data rows could
// be send back to the client. The given columns are encoded using the given
// format codes. Columns could be encoded as Text or Binary. If you provide a
// single format code, it will be applied to all columns.
func (columns wire_Columns) Define(ctx context.Context, writer *buffer.Writer, formats []wire_FormatCode) error {
	if len(columns) == 0 {
		return nil
	}

	writer.Start(types.ServerRowDescription)
	writer.AddInt16(int16(len(columns)))

	if len(formats) == 0 {
		formats = []wire_FormatCode{wire_TextFormat}
	}

	for index := range columns {
		format := formats[0]
		if len(formats) > index {
			format = formats[index]
		}

		columns[index].Define(ctx, writer, format)
	}

	return writer.End()
}

// Write writes the given column values back to the client. The given columns
// are encoded using the given format codes. Columns could be encoded as Text or
// Binary. If you provide a single format code, it will be applied to all
// columns.
func (columns wire_Columns) Write(ctx context.Context, formats []wire_FormatCode, writer *buffer.Writer, srcs []any) (err error) {
	if len(srcs) != len(columns) {
		return fmt.Errorf("unexpected columns, %d columns are defined inside the given table but %d were given", len(columns), len(srcs))
	}

	writer.Start(types.ServerDataRow)
	writer.AddInt16(int16(len(columns)))

	if len(formats) == 0 {
		formats = []wire_FormatCode{wire_TextFormat}
	}

	for index, column := range columns {
		format := formats[0]
		if len(formats) > index {
			format = formats[index]
		}

		err = column.Write(ctx, writer, format, srcs[index])
		if err != nil {
			return err
		}
	}

	return writer.End()
}

// Column represents a table column and its attributes such as name, type and
// encode formatter.
// https://www.postgresql.org/docs/8.3/catalog-pg-attribute.html
type wire_Column struct {
	Table        int32  // table id
	ID           int32  // column identifier
	Attr         int16  // column attribute number
	Name         string // column name
	AttrNo       int16  // column attribute no (optional)
	Oid          oid.Oid
	Width        int16
	TypeModifier int32
}

// Define writes the column header values to the given writer.
// This method is used to define a column inside RowDescription message defining
// the column type, width, and name.
func (column wire_Column) Define(ctx context.Context, writer *buffer.Writer, format wire_FormatCode) {
	writer.AddString(column.Name)
	writer.AddNullTerminate()
	writer.AddInt32(column.Table)
	writer.AddInt16(column.AttrNo)
	writer.AddInt32(int32(column.Oid))
	writer.AddInt16(column.Width)
	// TODO: Support type for type modifiers
	//
	// Some types could be overridden using the type modifier field within a RowDescription.
	// Type modifier (see pg_attribute.atttypmod). The meaning of the
	// modifier is type-specific.
	// Atttypmod records type-specific data supplied at table creation time (for
	// example, the maximum length of a varchar column). It is passed to
	// type-specific input functions and length coercion functions. The value
	// will generally be -1 for types that do not need atttypmod.
	//
	// https://www.postgresql.org/docs/current/protocol-message-formats.html
	// https://www.postgresql.org/docs/current/catalog-pg-attribute.html

	writer.AddInt32(-1)
	writer.AddInt16(int16(format))
}

// Write encodes the given source value using the column type definition and connection
// info. The encoded byte buffer is added to the given write buffer. This method
// Is used to encode values and return them inside a DataRow message.
func (column wire_Column) Write(ctx context.Context, writer *buffer.Writer, format wire_FormatCode, src any) (err error) {
	if ctx.Err() != nil {
		return ctx.Err()
	}

	tm := wire_TypeMap(ctx)
	if tm == nil {
		return errors.New("postgres connection info has not been defined inside the given context")
	}

	bb := make([]byte, 0)
	bb, err = tm.Encode(uint32(column.Oid), int16(format), src, bb)
	if err != nil {
		return err
	}

	// NOTE: The length of the column value, in bytes (this count does
	// not include itself). Can be zero. As a special case, -1 indicates a NULL
	// column value. No value bytes follow in the NULL case.
	length := int32(len(bb))
	if src == nil {
		length = -1
	}

	writer.AddInt32(length)
	writer.AddBytes(bb)

	return nil
}

// sslIdentifier represents a the bytes identifying whether the given connection
// supports SSL.
type wire_sslIdentifier []byte

var (
	wire_sslSupported   wire_sslIdentifier = []byte{'S'}
	wire_sslUnsupported wire_sslIdentifier = []byte{'N'}
)

// ListenAndServe opens a new Postgres server using the given address and
// default configurations. The given handler function is used to handle simple
// queries. This method should be used to construct a simple Postgres server for
// testing purposes or simple use cases.
func wire_ListenAndServe(address string, handler wire_ParseFn) error {
	server, err := wire_NewServer(handler)
	if err != nil {
		return err
	}

	return server.ListenAndServe(address)
}

// NewServer constructs a new Postgres server using the given address and server options.
func wire_NewServer(parse wire_ParseFn, options ...wire_OptionFn) (*wire_Server, error) {
	srv := &wire_Server{
		parse:      parse,
		logger:     slog.Default(),
		closer:     make(chan struct{}),
		types:      pgtype.NewMap(),
		Statements: &wire_DefaultStatementCache{},
		Portals:    &wire_DefaultPortalCache{},
		Session:    func(ctx context.Context) (context.Context, error) { return ctx, nil },
	}

	for _, option := range options {
		err := option(srv)
		if err != nil {
			return nil, fmt.Errorf("unexpected error while attempting to configure a new server: %w", err)
		}
	}

	return srv, nil
}

// Server contains options for listening to an address.
type wire_Server struct {
	closing         atomic.Bool
	wg              sync.WaitGroup
	logger          *slog.Logger
	types           *pgtype.Map
	Auth            wire_AuthStrategy
	BufferedMsgSize int
	Parameters      wire_Parameters
	Certificates    []tls.Certificate
	ClientCAs       *x509.CertPool
	ClientAuth      tls.ClientAuthType
	parse           wire_ParseFn
	Session         wire_SessionHandler
	Statements      wire_StatementCache
	Portals         wire_PortalCache
	CloseConn       wire_CloseFn
	TerminateConn   wire_CloseFn
	Version         string
	closer          chan struct{}
}

// ListenAndServe opens a new Postgres server on the preconfigured address and
// starts accepting and serving incoming client connections.
func (srv *wire_Server) ListenAndServe(address string) error {
	listener, err := net.Listen("tcp", address)
	if err != nil {
		return err
	}

	return srv.Serve(listener)
}

// Serve accepts and serves incoming Postgres client connections using the
// preconfigured configurations. The given listener will be closed once the
// server is gracefully closed.
func (srv *wire_Server) Serve(listener net.Listener) error {
	defer srv.logger.Info("closing server")

	srv.logger.Info("serving incoming connections", slog.String("addr", listener.Addr().String()))
	srv.wg.Add(1)

	// NOTE: handle graceful shutdowns
	go func() {
		defer srv.wg.Done()
		<-srv.closer

		err := listener.Close()
		if err != nil {
			srv.logger.Error("unexpected error while attempting to close the net listener", "err", err)
		}
	}()

	for {
		conn, err := listener.Accept()
		if errors.Is(err, net.ErrClosed) {
			return nil
		}

		if err != nil {
			return err
		}

		go func() {
			ctx := context.Background()
			err = srv.serve(ctx, conn)
			if err != nil {
				srv.logger.Error("an unexpected error got returned while serving a client connectio", "err", err)
			}
		}()
	}
}

func (srv *wire_Server) serve(ctx context.Context, conn net.Conn) error {
	ctx = wire_setTypeInfo(ctx, srv.types)
	defer conn.Close()

	srv.logger.Debug("serving a new client connection")

	conn, version, reader, err := srv.Handshake(conn)
	if err != nil {
		return err
	}

	if version == types.VersionCancel {
		return conn.Close()
	}

	srv.logger.Debug("handshake successfull, validating authentication")

	writer := buffer.NewWriter(srv.logger, conn)
	ctx, err = srv.readClientParameters(ctx, reader)
	if err != nil {
		return err
	}

	ctx, err = srv.handleAuth(ctx, reader, writer)
	if err != nil {
		return err
	}

	srv.logger.Debug("connection authenticated, writing server parameters")

	ctx, err = srv.writeParameters(ctx, writer, srv.Parameters)
	if err != nil {
		return err
	}

	ctx, err = srv.Session(ctx)
	if err != nil {
		return err
	}

	return srv.consumeCommands(ctx, conn, reader, writer)
}

// Close gracefully closes the underlaying Postgres server.
func (srv *wire_Server) Close() error {
	if srv.closing.Load() {
		return nil
	}

	srv.closing.Store(true)
	close(srv.closer)
	srv.wg.Wait()
	return nil
}

// DataWriter represents a writer interface for writing columns and data rows
// using the Postgres wire to the connected client.
type wire_DataWriter interface {
	// Row writes a single data row containing the values inside the given slice to
	// the underlaying Postgres client. The column headers have to be written before
	// sending rows. Each item inside the slice represents a single column value.
	// The slice length needs to be the same length as the defined columns. Nil
	// values are encoded as NULL values.
	Row([]any) error

	// Written returns the number of rows written to the client.
	Written() uint64

	// Empty announces to the client a empty response and that no data rows should
	// be expected.
	Empty() error

	// Complete announces to the client that the command has been completed and
	// no further data should be expected.
	Complete(description string) error
}

// ErrDataWritten is thrown when an empty result is attempted to be send to the
// client while data has already been written.
var wire_ErrDataWritten = errors.New("data has already been written")

// ErrClosedWriter is thrown when the data writer has been closed
var wire_ErrClosedWriter = errors.New("closed writer")

// NewDataWriter constructs a new data writer using the given context and
// buffer. The returned writer should be handled with caution as it is not safe
// for concurrent use. Concurrent access to the same data without proper
// synchronization can result in unexpected behavior and data corruption.
func wire_NewDataWriter(ctx context.Context, columns wire_Columns, formats []wire_FormatCode, writer *buffer.Writer) wire_DataWriter {
	return &wire_dataWriter{
		ctx:     ctx,
		columns: columns,
		formats: formats,
		client:  writer,
	}
}

// dataWriter is a implementation of the DataWriter interface.
type wire_dataWriter struct {
	ctx     context.Context
	columns wire_Columns
	formats []wire_FormatCode
	client  *buffer.Writer
	closed  bool
	written uint64
}

func (writer *wire_dataWriter) Define(columns wire_Columns) error {
	if writer.closed {
		return wire_ErrClosedWriter
	}

	writer.columns = columns
	return writer.columns.Define(writer.ctx, writer.client, writer.formats)
}

func (writer *wire_dataWriter) Row(values []any) error {
	if writer.closed {
		return wire_ErrClosedWriter
	}

	writer.written++

	return writer.columns.Write(writer.ctx, writer.formats, writer.client, values)
}

func (writer *wire_dataWriter) Empty() error {
	if writer.closed {
		return wire_ErrClosedWriter
	}

	if writer.written != 0 {
		return wire_ErrDataWritten
	}

	defer writer.close()
	return nil
}

func (writer *wire_dataWriter) Written() uint64 {
	return writer.written
}

func (writer *wire_dataWriter) Complete(description string) error {
	if writer.closed {
		return wire_ErrClosedWriter
	}

	if writer.written == 0 && writer.columns != nil {
		err := writer.Empty()
		if err != nil {
			return err
		}
	}

	defer writer.close()
	return wire_commandComplete(writer.client, description)
}

func (writer *wire_dataWriter) close() {
	writer.closed = true
}

// commandComplete announces that the requested command has successfully been executed.
// The given description is written back to the client and could be used to send
// additional meta data to the user.
func wire_commandComplete(writer *buffer.Writer, description string) error {
	writer.Start(types.ServerCommandComplete)
	writer.AddString(description)
	writer.AddNullTerminate()
	return writer.End()
}
