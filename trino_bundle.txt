// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o trino_bundle.go -pkg trino .

// Package trino provides a database/sql driver for Trino.
//
// The driver should be used via the database/sql package:
//
// 	import "database/sql"
// 	import _ "github.com/trinodb/trino-go-client/trino"
//
// 	dsn := "http://user@localhost:8080?catalog=default&schema=test"
// 	db, err := sql.Open("trino", dsn)
//

package trino

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"net/http"
	"net/url"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"gopkg.in/jcmturner/gokrb5.v6/client"
	"gopkg.in/jcmturner/gokrb5.v6/config"
	"gopkg.in/jcmturner/gokrb5.v6/keytab"
)

type trino_UnsupportedArgError struct {
	t string
}

func (e trino_UnsupportedArgError) Error() string {
	return fmt.Sprintf("trino: unsupported arg type: %s", e.t)
}

// Numeric is a string representation of a number, such as "10", "5.5" or in scientific form
// If another string format is used it will error to serialise
type trino_Numeric string

// trinoDate represents a Date type in Trino.
type trino_trinoDate struct {
	year  int
	month time.Month
	day   int
}

// Date creates a representation of a Trino Date type.
func trino_Date(year int, month time.Month, day int) trino_trinoDate {
	return trino_trinoDate{year, month, day}
}

// trinoTime represents a Time type in Trino.
type trino_trinoTime struct {
	hour       int
	minute     int
	second     int
	nanosecond int
}

// Time creates a representation of a Trino Time type. To represent time with precision higher than nanoseconds, pass the value as a string and use a cast in the query.
func trino_Time(hour int,
	minute int,
	second int,
	nanosecond int) trino_trinoTime {
	return trino_trinoTime{hour, minute, second, nanosecond}
}

// trinoTimeTz represents a Time(9) With Timezone type in Trino.
type trino_trinoTimeTz time.Time

// TimeTz creates a representation of a Trino Time(9) With Timezone type.
func trino_TimeTz(hour int,
	minute int,
	second int,
	nanosecond int,
	location *time.Location) trino_trinoTimeTz {
	// When reading a time, a nil location indicates UTC.
	// However, passing nil to time.Date() panics.
	if location == nil {
		location = time.UTC
	}
	return trino_trinoTimeTz(time.Date(0, 0, 0, hour, minute, second, nanosecond, location))
}

// Timestamp indicates we want a TimeStamp type WITHOUT a time zone in Trino from a Golang time.
type trino_trinoTimestamp time.Time

// Timestamp creates a representation of a Trino Timestamp(9) type.
func trino_Timestamp(year int,
	month time.Month,
	day int,
	hour int,
	minute int,
	second int,
	nanosecond int) trino_trinoTimestamp {
	return trino_trinoTimestamp(time.Date(year, month, day, hour, minute, second, nanosecond, time.UTC))
}

// Serial converts any supported value to its equivalent string for as a Trino parameter
// See https://trino.io/docs/current/language/types.html
func trino_Serial(v interface{}) (string, error) {
	switch x := v.(type) {
	case nil:
		return "NULL", nil

	// numbers convertible to int
	case int8:
		return strconv.Itoa(int(x)), nil
	case int16:
		return strconv.Itoa(int(x)), nil
	case int32:
		return strconv.Itoa(int(x)), nil
	case int:
		return strconv.Itoa(x), nil
	case uint16:
		return strconv.Itoa(int(x)), nil

	case int64:
		return strconv.FormatInt(x, 10), nil

	case uint32:
		return strconv.FormatUint(uint64(x), 10), nil
	case uint:
		return strconv.FormatUint(uint64(x), 10), nil
	case uint64:
		return strconv.FormatUint(x, 10), nil

		// float32, float64 not supported because digit precision will easily cause large problems
	case float32:
		return "", trino_UnsupportedArgError{"float32"}
	case float64:
		return "", trino_UnsupportedArgError{"float64"}

	case trino_Numeric:
		if _, err := strconv.ParseFloat(string(x), 64); err != nil {
			return "", err
		}
		return string(x), nil

		// note byte and uint are not supported, this is because byte is an alias for uint8
		// if you were to use uint8 (as a number) it could be interpreted as a byte, so it is unsupported
		// use string instead of byte and any other uint/int type for uint8
	case byte:
		return "", trino_UnsupportedArgError{"byte/uint8"}

	case bool:
		return strconv.FormatBool(x), nil

	case string:
		return "'" + strings.Replace(x, "'", "''", -1) + "'", nil

		// TODO - []byte should probably be matched to 'VARBINARY' in trino
	case []byte:
		return "", trino_UnsupportedArgError{"[]byte"}

	case trino_trinoDate:
		return fmt.Sprintf("DATE '%04d-%02d-%02d'", x.year, x.month, x.day), nil
	case trino_trinoTime:
		return fmt.Sprintf("TIME '%02d:%02d:%02d.%09d'", x.hour, x.minute, x.second, x.nanosecond), nil
	case trino_trinoTimeTz:
		return "TIME " + time.Time(x).Format("'15:04:05.999999999 Z07:00'"), nil
	case trino_trinoTimestamp:
		return "TIMESTAMP " + time.Time(x).Format("'2006-01-02 15:04:05.999999999'"), nil
	case time.Time:
		return "TIMESTAMP " + time.Time(x).Format("'2006-01-02 15:04:05.999999999 Z07:00'"), nil

	case time.Duration:
		return "", trino_UnsupportedArgError{"time.Duration"}

		// TODO - json.RawMesssage should probably be matched to 'JSON' in Trino
	case json.RawMessage:
		return "", trino_UnsupportedArgError{"json.RawMessage"}
	}

	if reflect.TypeOf(v).Kind() == reflect.Slice {
		x := reflect.ValueOf(v)
		if x.IsNil() {
			return "", trino_UnsupportedArgError{"[]<nil>"}
		}

		slice := make([]interface{}, x.Len())

		for i := 0; i < x.Len(); i++ {
			slice[i] = x.Index(i).Interface()
		}

		return trino_serialSlice(slice)
	}

	if reflect.TypeOf(v).Kind() == reflect.Map {
		// are Trino MAPs indifferent to order? Golang maps are, if Trino aren't then the two types can't be compatible
		return "", trino_UnsupportedArgError{"map"}
	}

	// TODO - consider the remaining types in https://trino.io/docs/current/language/types.html (Row, IP, ...)

	return "", trino_UnsupportedArgError{fmt.Sprintf("%T", v)}
}

func trino_serialSlice(v []interface{}) (string, error) {
	ss := make([]string, len(v))

	for i, x := range v {
		s, err := trino_Serial(x)
		if err != nil {
			return "", err
		}
		ss[i] = s
	}

	return "ARRAY[" + strings.Join(ss, ", ") + "]", nil
}

func init() {
	sql.Register("trino", &trino_Driver{})
}

var (
	// DefaultQueryTimeout is the default timeout for queries executed without a context.
	trino_DefaultQueryTimeout = 60 * time.Second

	// DefaultCancelQueryTimeout is the timeout for the request to cancel queries in Trino.
	trino_DefaultCancelQueryTimeout = 30 * time.Second

	// ErrOperationNotSupported indicates that a database operation is not supported.
	trino_ErrOperationNotSupported = errors.New("trino: operation not supported")

	// ErrQueryCancelled indicates that a query has been cancelled.
	trino_ErrQueryCancelled = errors.New("trino: query cancelled")

	// ErrUnsupportedHeader indicates that the server response contains an unsupported header.
	trino_ErrUnsupportedHeader = errors.New("trino: server response contains an unsupported header")

	// ErrInvalidResponseType indicates that the server returned an invalid type definition.
	trino_ErrInvalidResponseType = errors.New("trino: server response contains an invalid type")

	// ErrInvalidProgressCallbackHeader indicates that server did not get valid headers for progress callback
	trino_ErrInvalidProgressCallbackHeader = errors.New("trino: both " + trino_trinoProgressCallbackParam + " and " + trino_trinoProgressCallbackPeriodParam + " must be set when using progress callback")
)

const (
	trino_trinoHeaderPrefix = `X-Trino-`

	trino_preparedStatementHeader = trino_trinoHeaderPrefix + "Prepared-Statement"
	trino_preparedStatementName   = "_trino_go"

	trino_trinoUserHeader            = trino_trinoHeaderPrefix + `User`
	trino_trinoSourceHeader          = trino_trinoHeaderPrefix + `Source`
	trino_trinoCatalogHeader         = trino_trinoHeaderPrefix + `Catalog`
	trino_trinoSchemaHeader          = trino_trinoHeaderPrefix + `Schema`
	trino_trinoSessionHeader         = trino_trinoHeaderPrefix + `Session`
	trino_trinoSetCatalogHeader      = trino_trinoHeaderPrefix + `Set-Catalog`
	trino_trinoSetSchemaHeader       = trino_trinoHeaderPrefix + `Set-Schema`
	trino_trinoSetPathHeader         = trino_trinoHeaderPrefix + `Set-Path`
	trino_trinoSetSessionHeader      = trino_trinoHeaderPrefix + `Set-Session`
	trino_trinoClearSessionHeader    = trino_trinoHeaderPrefix + `Clear-Session`
	trino_trinoSetRoleHeader         = trino_trinoHeaderPrefix + `Set-Role`
	trino_trinoExtraCredentialHeader = trino_trinoHeaderPrefix + `Extra-Credential`

	trino_trinoProgressCallbackParam       = trino_trinoHeaderPrefix + `Progress-Callback`
	trino_trinoProgressCallbackPeriodParam = trino_trinoHeaderPrefix + `Progress-Callback-Period`

	trino_trinoAddedPrepareHeader       = trino_trinoHeaderPrefix + `Added-Prepare`
	trino_trinoDeallocatedPrepareHeader = trino_trinoHeaderPrefix + `Deallocated-Prepare`

	trino_KerberosEnabledConfig    = "KerberosEnabled"
	trino_kerberosKeytabPathConfig = "KerberosKeytabPath"
	trino_kerberosPrincipalConfig  = "KerberosPrincipal"
	trino_kerberosRealmConfig      = "KerberosRealm"
	trino_kerberosConfigPathConfig = "KerberosConfigPath"
	trino_SSLCertPathConfig        = "SSLCertPath"
	trino_SSLCertConfig            = "SSLCert"
)

var (
	trino_responseToRequestHeaderMap = map[string]string{
		trino_trinoSetSchemaHeader:  trino_trinoSchemaHeader,
		trino_trinoSetCatalogHeader: trino_trinoCatalogHeader,
	}
	trino_unsupportedResponseHeaders = []string{
		trino_trinoSetPathHeader,
		trino_trinoSetRoleHeader,
	}
)

type trino_Driver struct{}

func (d *trino_Driver) Open(name string) (driver.Conn, error) {
	return trino_newConn(name)
}

var _ driver.Driver = &trino_Driver{}

// Config is a configuration that can be encoded to a DSN string.
type trino_Config struct {
	ServerURI          string            // URI of the Trino server, e.g. http://user@localhost:8080
	Source             string            // Source of the connection (optional)
	Catalog            string            // Catalog (optional)
	Schema             string            // Schema (optional)
	SessionProperties  map[string]string // Session properties (optional)
	ExtraCredentials   map[string]string // Extra credentials (optional)
	CustomClientName   string            // Custom client name (optional)
	KerberosEnabled    string            // KerberosEnabled (optional, default is false)
	KerberosKeytabPath string            // Kerberos Keytab Path (optional)
	KerberosPrincipal  string            // Kerberos Principal used to authenticate to KDC (optional)
	KerberosRealm      string            // The Kerberos Realm (optional)
	KerberosConfigPath string            // The krb5 config path (optional)
	SSLCertPath        string            // The SSL cert path for TLS verification (optional)
	SSLCert            string            // The SSL cert for TLS verification (optional)
}

// FormatDSN returns a DSN string from the configuration.
func (c *trino_Config) FormatDSN() (string, error) {
	serverURL, err := url.Parse(c.ServerURI)
	if err != nil {
		return "", err
	}
	var sessionkv []string
	if c.SessionProperties != nil {
		for k, v := range c.SessionProperties {
			sessionkv = append(sessionkv, k+"="+v)
		}
	}
	var credkv []string
	if c.ExtraCredentials != nil {
		for k, v := range c.ExtraCredentials {
			credkv = append(credkv, k+"="+v)
		}
	}
	source := c.Source
	if source == "" {
		source = "trino-go-client"
	}
	query := make(url.Values)
	query.Add("source", source)

	KerberosEnabled, _ := strconv.ParseBool(c.KerberosEnabled)
	isSSL := serverURL.Scheme == "https"

	if c.CustomClientName != "" {
		if c.SSLCert != "" || c.SSLCertPath != "" {
			return "", fmt.Errorf("trino: client configuration error, a custom client cannot be specific together with a custom SSL certificate")
		}
	}
	if c.SSLCertPath != "" {
		if !isSSL {
			return "", fmt.Errorf("trino: client configuration error, SSL must be enabled to specify a custom SSL certificate file")
		}
		if c.SSLCert != "" {
			return "", fmt.Errorf("trino: client configuration error, a custom SSL certificate file cannot be specified together with a certificate string")
		}
		query.Add(trino_SSLCertPathConfig, c.SSLCertPath)
	}

	if c.SSLCert != "" {
		if !isSSL {
			return "", fmt.Errorf("trino: client configuration error, SSL must be enabled to specify a custom SSL certificate")
		}
		if c.SSLCertPath != "" {
			return "", fmt.Errorf("trino: client configuration error, a custom SSL certificate string cannot be specified together with a certificate file")
		}
		query.Add(trino_SSLCertConfig, c.SSLCert)
	}

	if KerberosEnabled {
		query.Add(trino_KerberosEnabledConfig, "true")
		query.Add(trino_kerberosKeytabPathConfig, c.KerberosKeytabPath)
		query.Add(trino_kerberosPrincipalConfig, c.KerberosPrincipal)
		query.Add(trino_kerberosRealmConfig, c.KerberosRealm)
		query.Add(trino_kerberosConfigPathConfig, c.KerberosConfigPath)
		if !isSSL {
			return "", fmt.Errorf("trino: client configuration error, SSL must be enabled for secure env")
		}
	}

	// ensure consistent order of items
	sort.Strings(sessionkv)
	sort.Strings(credkv)

	for k, v := range map[string]string{
		"catalog":            c.Catalog,
		"schema":             c.Schema,
		"session_properties": strings.Join(sessionkv, ","),
		"extra_credentials":  strings.Join(credkv, ","),
		"custom_client":      c.CustomClientName,
	} {
		if v != "" {
			query[k] = []string{v}
		}
	}
	serverURL.RawQuery = query.Encode()
	return serverURL.String(), nil
}

// Conn is a Trino connection.
type trino_Conn struct {
	baseURL               string
	auth                  *url.Userinfo
	httpClient            http.Client
	httpHeaders           http.Header
	kerberosClient        client.Client
	kerberosEnabled       bool
	progressUpdater       trino_ProgressUpdater
	progressUpdaterPeriod trino_queryProgressCallbackPeriod
}

var (
	_ driver.Conn               = &trino_Conn{}
	_ driver.ConnPrepareContext = &trino_Conn{}
)

func trino_newConn(dsn string) (*trino_Conn, error) {
	serverURL, err := url.Parse(dsn)
	if err != nil {
		return nil, fmt.Errorf("trino: malformed dsn: %w", err)
	}

	query := serverURL.Query()

	kerberosEnabled, _ := strconv.ParseBool(query.Get(trino_KerberosEnabledConfig))

	var kerberosClient client.Client

	if kerberosEnabled {
		kt, err := keytab.Load(query.Get(trino_kerberosKeytabPathConfig))
		if err != nil {
			return nil, fmt.Errorf("trino: Error loading Keytab: %w", err)
		}

		kerberosClient = client.NewClientWithKeytab(query.Get(trino_kerberosPrincipalConfig), query.Get(trino_kerberosRealmConfig), kt)
		conf, err := config.Load(query.Get(trino_kerberosConfigPathConfig))
		if err != nil {
			return nil, fmt.Errorf("trino: Error loading krb config: %w", err)
		}

		kerberosClient.WithConfig(conf)

		loginErr := kerberosClient.Login()
		if loginErr != nil {
			return nil, fmt.Errorf("trino: Error login to KDC: %v", loginErr)
		}
	}

	var httpClient = http.DefaultClient
	if clientKey := query.Get("custom_client"); clientKey != "" {
		httpClient = trino_getCustomClient(clientKey)
		if httpClient == nil {
			return nil, fmt.Errorf("trino: custom client not registered: %q", clientKey)
		}
	} else if serverURL.Scheme == "https" {

		cert := []byte(query.Get(trino_SSLCertConfig))

		if certPath := query.Get(trino_SSLCertPathConfig); certPath != "" {
			cert, err = ioutil.ReadFile(certPath)
			if err != nil {
				return nil, fmt.Errorf("trino: Error loading SSL Cert File: %w", err)
			}
		}

		if len(cert) != 0 {
			certPool := x509.NewCertPool()
			certPool.AppendCertsFromPEM(cert)

			httpClient = &http.Client{
				Transport: &http.Transport{
					TLSClientConfig: &tls.Config{
						RootCAs: certPool,
					},
				},
			}
		}
	}

	c := &trino_Conn{
		baseURL:         serverURL.Scheme + "://" + serverURL.Host,
		httpClient:      *httpClient,
		httpHeaders:     make(http.Header),
		kerberosClient:  kerberosClient,
		kerberosEnabled: kerberosEnabled,
	}

	var user string
	if serverURL.User != nil {
		user = serverURL.User.Username()
		pass, _ := serverURL.User.Password()
		if pass != "" && serverURL.Scheme == "https" {
			c.auth = serverURL.User
		}
	}

	for k, v := range map[string]string{
		trino_trinoUserHeader:            user,
		trino_trinoSourceHeader:          query.Get("source"),
		trino_trinoCatalogHeader:         query.Get("catalog"),
		trino_trinoSchemaHeader:          query.Get("schema"),
		trino_trinoSessionHeader:         query.Get("session_properties"),
		trino_trinoExtraCredentialHeader: query.Get("extra_credentials"),
	} {
		if v != "" {
			c.httpHeaders.Add(k, v)
		}
	}

	return c, nil
}

// registry for custom http clients
var trino_customClientRegistry = struct {
	sync.RWMutex
	Index map[string]http.Client
}{
	Index: make(map[string]http.Client),
}

// RegisterCustomClient associates a client to a key in the driver's registry.
//
// Register your custom client in the driver, then refer to it by name in the DSN, on the call to sql.Open:
//
//	foobarClient := &http.Client{
//		Transport: &http.Transport{
//			Proxy: http.ProxyFromEnvironment,
//			DialContext: (&net.Dialer{
//				Timeout:   30 * time.Second,
//				KeepAlive: 30 * time.Second,
//				DualStack: true,
//			}).DialContext,
//			MaxIdleConns:          100,
//			IdleConnTimeout:       90 * time.Second,
//			TLSHandshakeTimeout:   10 * time.Second,
//			ExpectContinueTimeout: 1 * time.Second,
//			TLSClientConfig:       &tls.Config{
//			// your config here...
//			},
//		},
//	}
//	trino.RegisterCustomClient("foobar", foobarClient)
//	db, err := sql.Open("trino", "https://user@localhost:8080?custom_client=foobar")
func trino_RegisterCustomClient(key string, client *http.Client) error {
	if _, err := strconv.ParseBool(key); err == nil {
		return fmt.Errorf("trino: custom client key %q is reserved", key)
	}
	trino_customClientRegistry.Lock()
	trino_customClientRegistry.Index[key] = *client
	trino_customClientRegistry.Unlock()
	return nil
}

// DeregisterCustomClient removes the client associated to the key.
func trino_DeregisterCustomClient(key string) {
	trino_customClientRegistry.Lock()
	delete(trino_customClientRegistry.Index, key)
	trino_customClientRegistry.Unlock()
}

func trino_getCustomClient(key string) *http.Client {
	trino_customClientRegistry.RLock()
	defer trino_customClientRegistry.RUnlock()
	if client, ok := trino_customClientRegistry.Index[key]; ok {
		return &client
	}
	return nil
}

// Begin implements the driver.Conn interface.
func (c *trino_Conn) Begin() (driver.Tx, error) {
	return nil, trino_ErrOperationNotSupported
}

// Prepare implements the driver.Conn interface.
func (c *trino_Conn) Prepare(query string) (driver.Stmt, error) {
	return nil, driver.ErrSkip
}

// PrepareContext implements the driver.ConnPrepareContext interface.
func (c *trino_Conn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {
	return &trino_driverStmt{conn: c, query: query}, nil
}

// Close implements the driver.Conn interface.
func (c *trino_Conn) Close() error {
	return nil
}

func (c *trino_Conn) newRequest(method, url string, body io.Reader, hs http.Header) (*http.Request, error) {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, fmt.Errorf("trino: %w", err)
	}

	if c.kerberosEnabled {
		err = c.kerberosClient.SetSPNEGOHeader(req, "trino/"+req.URL.Hostname())
		if err != nil {
			return nil, fmt.Errorf("error setting client SPNEGO header: %w", err)
		}
	}

	for k, v := range c.httpHeaders {
		req.Header[k] = v
	}
	for k, v := range hs {
		req.Header[k] = v
	}

	if c.auth != nil {
		pass, _ := c.auth.Password()
		req.SetBasicAuth(c.auth.Username(), pass)
	}
	return req, nil
}

func (c *trino_Conn) roundTrip(ctx context.Context, req *http.Request) (*http.Response, error) {
	delay := 100 * time.Millisecond
	const maxDelayBetweenRequests = float64(15 * time.Second)
	timer := time.NewTimer(0)
	defer timer.Stop()
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-timer.C:
			timeout := trino_DefaultQueryTimeout
			if deadline, ok := ctx.Deadline(); ok {
				timeout = time.Until(deadline)
			}
			client := c.httpClient
			client.Timeout = timeout
			req.Cancel = ctx.Done()
			resp, err := client.Do(req)
			if err != nil {
				return nil, &trino_ErrQueryFailed{Reason: err}
			}
			switch resp.StatusCode {
			case http.StatusOK:
				for src, dst := range trino_responseToRequestHeaderMap {
					if v := resp.Header.Get(src); v != "" {
						c.httpHeaders.Set(dst, v)
					}
				}
				if v := resp.Header.Get(trino_trinoAddedPrepareHeader); v != "" {
					c.httpHeaders.Add(trino_preparedStatementHeader, v)
				}
				if v := resp.Header.Get(trino_trinoDeallocatedPrepareHeader); v != "" {
					values := c.httpHeaders.Values(trino_preparedStatementHeader)
					c.httpHeaders.Del(trino_preparedStatementHeader)
					for _, v2 := range values {
						if !strings.HasPrefix(v2, v+"=") {
							c.httpHeaders.Add(trino_preparedStatementHeader, v2)
						}
					}
				}
				if v := resp.Header.Get(trino_trinoSetSessionHeader); v != "" {
					c.httpHeaders.Add(trino_trinoSessionHeader, v)
				}
				if v := resp.Header.Get(trino_trinoClearSessionHeader); v != "" {
					values := c.httpHeaders.Values(trino_trinoSessionHeader)
					c.httpHeaders.Del(trino_trinoSessionHeader)
					for _, v2 := range values {
						if !strings.HasPrefix(v2, v+"=") {
							c.httpHeaders.Add(trino_trinoSessionHeader, v2)
						}
					}
				}
				for _, name := range trino_unsupportedResponseHeaders {
					if v := resp.Header.Get(name); v != "" {
						return nil, trino_ErrUnsupportedHeader
					}
				}
				return resp, nil
			case http.StatusServiceUnavailable:
				resp.Body.Close()
				timer.Reset(delay)
				delay = time.Duration(math.Min(
					float64(delay)*math.Phi,
					maxDelayBetweenRequests,
				))
				continue
			default:
				return nil, trino_newErrQueryFailedFromResponse(resp)
			}
		}
	}
}

// ErrQueryFailed indicates that a query to Trino failed.
type trino_ErrQueryFailed struct {
	StatusCode int
	Reason     error
}

// Error implements the error interface.
func (e *trino_ErrQueryFailed) Error() string {
	return fmt.Sprintf("trino: query failed (%d %s): %q",
		e.StatusCode, http.StatusText(e.StatusCode), e.Reason)
}

func trino_newErrQueryFailedFromResponse(resp *http.Response) *trino_ErrQueryFailed {
	const maxBytes = 8 * 1024
	defer resp.Body.Close()
	qf := &trino_ErrQueryFailed{StatusCode: resp.StatusCode}
	b, err := ioutil.ReadAll(io.LimitReader(resp.Body, maxBytes))
	if err != nil {
		qf.Reason = err
		return qf
	}
	reason := string(b)
	if resp.ContentLength > maxBytes {
		reason += "..."
	}
	qf.Reason = errors.New(reason)
	return qf
}

type trino_driverStmt struct {
	conn           *trino_Conn
	query          string
	user           string
	nextURIs       chan string
	httpResponses  chan *http.Response
	queryResponses chan trino_queryResponse
	statsCh        chan trino_QueryProgressInfo
	errors         chan error
	doneCh         chan struct{}
}

var (
	_ driver.Stmt              = &trino_driverStmt{}
	_ driver.StmtQueryContext  = &trino_driverStmt{}
	_ driver.StmtExecContext   = &trino_driverStmt{}
	_ driver.NamedValueChecker = &trino_driverStmt{}
)

// Close closes statement just before releasing connection
func (st *trino_driverStmt) Close() error {
	if st.doneCh == nil {
		return nil
	}
	close(st.doneCh)
	if st.statsCh != nil {
		<-st.statsCh
		st.statsCh = nil
	}
	go func() {
		// drain errors chan to allow goroutines to write to it
		for range st.errors {
		}
	}()
	for range st.queryResponses {
	}
	for range st.httpResponses {
	}
	close(st.nextURIs)
	close(st.errors)
	st.doneCh = nil
	return nil
}

func (st *trino_driverStmt) NumInput() int {
	return -1
}

func (st *trino_driverStmt) Exec(args []driver.Value) (driver.Result, error) {
	return nil, driver.ErrSkip
}

func (st *trino_driverStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {
	sr, err := st.exec(ctx, args)
	if err != nil {
		return nil, err
	}
	rows := &trino_driverRows{
		ctx:          ctx,
		stmt:         st,
		queryID:      sr.ID,
		nextURI:      sr.NextURI,
		rowsAffected: sr.UpdateCount,
		statsCh:      st.statsCh,
		doneCh:       st.doneCh,
	}
	// consume all results, if there are any
	for err == nil {
		err = rows.fetch()
	}

	if err != nil && err != io.EOF {
		return nil, err
	}
	return rows, nil
}

func (st *trino_driverStmt) CheckNamedValue(arg *driver.NamedValue) error {
	switch arg.Value.(type) {
	case nil:
		return nil
	case trino_Numeric, trino_trinoDate, trino_trinoTime, trino_trinoTimeTz, trino_trinoTimestamp:
		return nil
	default:
		{
			if reflect.TypeOf(arg.Value).Kind() == reflect.Slice {
				return nil
			}

			if arg.Name == trino_trinoProgressCallbackParam {
				return nil
			}
			if arg.Name == trino_trinoProgressCallbackPeriodParam {
				return nil
			}
		}
	}

	return driver.ErrSkip
}

type trino_stmtResponse struct {
	ID          string          `json:"id"`
	InfoURI     string          `json:"infoUri"`
	NextURI     string          `json:"nextUri"`
	Stats       trino_stmtStats `json:"stats"`
	Error       trino_stmtError `json:"error"`
	UpdateType  string          `json:"updateType"`
	UpdateCount int64           `json:"updateCount"`
}

type trino_stmtStats struct {
	State                string          `json:"state"`
	Scheduled            bool            `json:"scheduled"`
	Nodes                int             `json:"nodes"`
	TotalSplits          int             `json:"totalSplits"`
	QueuesSplits         int             `json:"queuedSplits"`
	RunningSplits        int             `json:"runningSplits"`
	CompletedSplits      int             `json:"completedSplits"`
	UserTimeMillis       int             `json:"userTimeMillis"`
	CPUTimeMillis        int64           `json:"cpuTimeMillis"`
	WallTimeMillis       int64           `json:"wallTimeMillis"`
	QueuedTimeMillis     int64           `json:"queuedTimeMillis"`
	ElapsedTimeMillis    int64           `json:"elapsedTimeMillis"`
	ProcessedRows        int64           `json:"processedRows"`
	ProcessedBytes       int64           `json:"processedBytes"`
	PhysicalInputBytes   int64           `json:"physicalInputBytes"`
	PhysicalWrittenBytes int64           `json:"physicalWrittenBytes"`
	PeakMemoryBytes      int64           `json:"peakMemoryBytes"`
	SpilledBytes         int64           `json:"spilledBytes"`
	RootStage            trino_stmtStage `json:"rootStage"`
	ProgressPercentage   float32         `json:"progressPercentage"`
	RunningPercentage    float32         `json:"runningPercentage"`
}

type trino_stmtError struct {
	Message       string                     `json:"message"`
	ErrorName     string                     `json:"errorName"`
	ErrorCode     int                        `json:"errorCode"`
	ErrorLocation trino_stmtErrorLocation    `json:"errorLocation"`
	FailureInfo   trino_stmtErrorFailureInfo `json:"failureInfo"`
	// Other fields omitted
}

type trino_stmtErrorLocation struct {
	LineNumber   int `json:"lineNumber"`
	ColumnNumber int `json:"columnNumber"`
}

type trino_stmtErrorFailureInfo struct {
	Type string `json:"type"`
	// Other fields omitted
}

func (e trino_stmtError) Error() string {
	return e.FailureInfo.Type + ": " + e.Message
}

type trino_stmtStage struct {
	StageID         string            `json:"stageId"`
	State           string            `json:"state"`
	Done            bool              `json:"done"`
	Nodes           int               `json:"nodes"`
	TotalSplits     int               `json:"totalSplits"`
	QueuedSplits    int               `json:"queuedSplits"`
	RunningSplits   int               `json:"runningSplits"`
	CompletedSplits int               `json:"completedSplits"`
	UserTimeMillis  int               `json:"userTimeMillis"`
	CPUTimeMillis   int               `json:"cpuTimeMillis"`
	WallTimeMillis  int               `json:"wallTimeMillis"`
	ProcessedRows   int               `json:"processedRows"`
	ProcessedBytes  int               `json:"processedBytes"`
	SubStages       []trino_stmtStage `json:"subStages"`
}

func (st *trino_driverStmt) Query(args []driver.Value) (driver.Rows, error) {
	return nil, driver.ErrSkip
}

func (st *trino_driverStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {
	sr, err := st.exec(ctx, args)
	if err != nil {
		return nil, err
	}
	rows := &trino_driverRows{
		ctx:     ctx,
		stmt:    st,
		queryID: sr.ID,
		nextURI: sr.NextURI,
		statsCh: st.statsCh,
		doneCh:  st.doneCh,
	}
	if err = rows.fetch(); err != nil && err != io.EOF {
		return nil, err
	}
	return rows, nil
}

func (st *trino_driverStmt) exec(ctx context.Context, args []driver.NamedValue) (*trino_stmtResponse, error) {
	query := st.query
	hs := make(http.Header)
	// Ensure the server returns timestamps preserving their precision, without truncating them to timestamp(3).
	hs.Add("X-Trino-Client-Capabilities", "PARAMETRIC_DATETIME")

	if len(args) > 0 {
		var ss []string
		for _, arg := range args {
			if arg.Name == trino_trinoProgressCallbackParam {
				st.conn.progressUpdater = arg.Value.(trino_ProgressUpdater)
				continue
			}
			if arg.Name == trino_trinoProgressCallbackPeriodParam {
				st.conn.progressUpdaterPeriod.Period = arg.Value.(time.Duration)
				continue
			}

			s, err := trino_Serial(arg.Value)
			if err != nil {
				return nil, err
			}

			if strings.HasPrefix(arg.Name, trino_trinoHeaderPrefix) {
				headerValue := arg.Value.(string)

				if arg.Name == trino_trinoUserHeader {
					st.user = headerValue
				}

				hs.Add(arg.Name, headerValue)
			} else {
				if hs.Get(trino_preparedStatementHeader) == "" {
					for _, v := range st.conn.httpHeaders.Values(trino_preparedStatementHeader) {
						hs.Add(trino_preparedStatementHeader, v)
					}
					hs.Add(trino_preparedStatementHeader, trino_preparedStatementName+"="+url.QueryEscape(st.query))
				}
				ss = append(ss, s)
			}
		}
		if (st.conn.progressUpdater != nil && st.conn.progressUpdaterPeriod.Period == 0) || (st.conn.progressUpdater == nil && st.conn.progressUpdaterPeriod.Period > 0) {
			return nil, trino_ErrInvalidProgressCallbackHeader
		}
		if len(ss) > 0 {
			query = "EXECUTE " + trino_preparedStatementName + " USING " + strings.Join(ss, ", ")
		}
	}

	req, err := st.conn.newRequest("POST", st.conn.baseURL+"/v1/statement", strings.NewReader(query), hs)
	if err != nil {
		return nil, err
	}

	resp, err := st.conn.roundTrip(ctx, req)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()
	var sr trino_stmtResponse
	d := json.NewDecoder(resp.Body)
	d.UseNumber()
	err = d.Decode(&sr)
	if err != nil {
		return nil, fmt.Errorf("trino: %w", err)
	}

	st.doneCh = make(chan struct{})
	st.nextURIs = make(chan string)
	st.httpResponses = make(chan *http.Response)
	st.queryResponses = make(chan trino_queryResponse)
	st.errors = make(chan error)
	go func() {
		defer close(st.httpResponses)
		for {
			select {
			case nextURI := <-st.nextURIs:
				if nextURI == "" {
					return
				}
				hs := make(http.Header)
				hs.Add(trino_trinoUserHeader, st.user)
				req, err := st.conn.newRequest("GET", nextURI, nil, hs)
				if err != nil {
					st.errors <- err
					return
				}
				resp, err := st.conn.roundTrip(ctx, req)
				if err != nil {
					if ctx.Err() == context.Canceled {
						st.errors <- context.Canceled
						return
					}
					st.errors <- err
					return
				}
				select {
				case st.httpResponses <- resp:
				case <-st.doneCh:
					return
				}
			case <-st.doneCh:
				return
			}
		}
	}()
	go func() {
		defer close(st.queryResponses)
		for {
			select {
			case resp := <-st.httpResponses:
				if resp == nil {
					return
				}
				var qresp trino_queryResponse
				d := json.NewDecoder(resp.Body)
				d.UseNumber()
				err = d.Decode(&qresp)
				if err != nil {
					st.errors <- fmt.Errorf("trino: %w", err)
					return
				}
				err = resp.Body.Close()
				if err != nil {
					st.errors <- err
					return
				}
				err = trino_handleResponseError(resp.StatusCode, qresp.Error)
				if err != nil {
					st.errors <- err
					return
				}
				select {
				case st.nextURIs <- qresp.NextURI:
				case <-st.doneCh:
					return
				}
				select {
				case st.queryResponses <- qresp:
				case <-st.doneCh:
					return
				}
			case <-st.doneCh:
				return
			}
		}
	}()
	st.nextURIs <- sr.NextURI
	if st.conn.progressUpdater != nil {
		st.statsCh = make(chan trino_QueryProgressInfo)

		// progress updater go func
		go func() {
			for {
				select {
				case stats := <-st.statsCh:
					st.conn.progressUpdater.Update(stats)
				case <-st.doneCh:
					close(st.statsCh)
					return
				}
			}
		}()

		// initial progress callback call
		srStats := trino_QueryProgressInfo{
			QueryId:    sr.ID,
			QueryStats: sr.Stats,
		}
		select {
		case st.statsCh <- srStats:
		default:
			// ignore when can't send stats
		}
		st.conn.progressUpdaterPeriod.LastCallbackTime = time.Now()
		st.conn.progressUpdaterPeriod.LastQueryState = sr.Stats.State
	}
	return &sr, trino_handleResponseError(resp.StatusCode, sr.Error)
}

type trino_driverRows struct {
	ctx     context.Context
	stmt    *trino_driverStmt
	queryID string
	nextURI string

	err          error
	rowindex     int
	columns      []string
	coltype      []*trino_typeConverter
	data         []trino_queryData
	rowsAffected int64

	statsCh chan trino_QueryProgressInfo
	doneCh  chan struct{}
}

var _ driver.Rows = &trino_driverRows{}

var _ driver.Result = &trino_driverRows{}

var _ driver.RowsColumnTypeScanType = &trino_driverRows{}

var _ driver.RowsColumnTypeDatabaseTypeName = &trino_driverRows{}

var _ driver.RowsColumnTypeLength = &trino_driverRows{}

var _ driver.RowsColumnTypePrecisionScale = &trino_driverRows{}

// Close closes the rows iterator.
func (qr *trino_driverRows) Close() error {
	if qr.err == sql.ErrNoRows || qr.err == io.EOF {
		return nil
	}
	qr.err = io.EOF
	hs := make(http.Header)
	if qr.stmt.user != "" {
		hs.Add(trino_trinoUserHeader, qr.stmt.user)
	}
	req, err := qr.stmt.conn.newRequest("DELETE", qr.stmt.conn.baseURL+"/v1/query/"+url.PathEscape(qr.queryID), nil, hs)
	if err != nil {
		return err
	}
	ctx, cancel := context.WithTimeout(context.Background(), trino_DefaultCancelQueryTimeout)
	defer cancel()
	resp, err := qr.stmt.conn.roundTrip(ctx, req)
	if err != nil {
		qferr, ok := err.(*trino_ErrQueryFailed)
		if ok && qferr.StatusCode == http.StatusNoContent {
			qr.nextURI = ""
			return nil
		}
		return err
	}
	resp.Body.Close()
	return qr.err
}

// Columns returns the names of the columns.
func (qr *trino_driverRows) Columns() []string {
	if qr.err != nil {
		return []string{}
	}
	if qr.columns == nil {
		if err := qr.fetch(); err != nil && err != io.EOF {
			qr.err = err
			return []string{}
		}
	}
	return qr.columns
}

func (qr *trino_driverRows) ColumnTypeDatabaseTypeName(index int) string {
	typeName := qr.coltype[index].parsedType[0]
	if typeName == "map" || typeName == "array" || typeName == "row" {
		typeName = qr.coltype[index].typeName
	}
	return strings.ToUpper(typeName)
}

func (qr *trino_driverRows) ColumnTypeScanType(index int) reflect.Type {
	return qr.coltype[index].scanType
}

func (qr *trino_driverRows) ColumnTypeLength(index int) (int64, bool) {
	return qr.coltype[index].size.value, qr.coltype[index].size.hasValue
}

func (qr *trino_driverRows) ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool) {
	return qr.coltype[index].precision.value, qr.coltype[index].scale.value, qr.coltype[index].precision.hasValue
}

// Next is called to populate the next row of data into
// the provided slice. The provided slice will be the same
// size as the Columns() are wide.
//
// Next should return io.EOF when there are no more rows.
func (qr *trino_driverRows) Next(dest []driver.Value) error {
	if qr.err != nil {
		return qr.err
	}
	if qr.columns == nil || qr.rowindex >= len(qr.data) {
		if qr.nextURI == "" {
			qr.err = io.EOF
			return qr.err
		}
		if err := qr.fetch(); err != nil {
			qr.err = err
			return err
		}
	}
	if len(qr.coltype) == 0 {
		qr.err = sql.ErrNoRows
		return qr.err
	}
	for i, v := range qr.coltype {
		if i > len(dest)-1 {
			break
		}
		vv, err := v.ConvertValue(qr.data[qr.rowindex][i])
		if err != nil {
			qr.err = err
			return err
		}
		dest[i] = vv
	}
	qr.rowindex++
	return nil
}

// LastInsertId returns the database's auto-generated ID
// after, for example, an INSERT into a table with primary
// key.
func (qr trino_driverRows) LastInsertId() (int64, error) {
	return 0, trino_ErrOperationNotSupported
}

// RowsAffected returns the number of rows affected by the query.
func (qr trino_driverRows) RowsAffected() (int64, error) {
	return qr.rowsAffected, nil
}

type trino_queryResponse struct {
	ID               string              `json:"id"`
	InfoURI          string              `json:"infoUri"`
	PartialCancelURI string              `json:"partialCancelUri"`
	NextURI          string              `json:"nextUri"`
	Columns          []trino_queryColumn `json:"columns"`
	Data             []trino_queryData   `json:"data"`
	Stats            trino_stmtStats     `json:"stats"`
	Error            trino_stmtError     `json:"error"`
	UpdateType       string              `json:"updateType"`
	UpdateCount      int64               `json:"updateCount"`
}

type trino_queryColumn struct {
	Name          string              `json:"name"`
	Type          string              `json:"type"`
	TypeSignature trino_typeSignature `json:"typeSignature"`
}

type trino_queryData []interface{}

type trino_namedTypeSignature struct {
	FieldName     trino_rowFieldName  `json:"fieldName"`
	TypeSignature trino_typeSignature `json:"typeSignature"`
}

type trino_rowFieldName struct {
	Name string `json:"name"`
}

type trino_typeSignature struct {
	RawType   string               `json:"rawType"`
	Arguments []trino_typeArgument `json:"arguments"`
}

type trino_typeKind string

const (
	trino_KIND_TYPE       = trino_typeKind("TYPE")
	trino_KIND_NAMED_TYPE = trino_typeKind("NAMED_TYPE")
	trino_KIND_LONG       = trino_typeKind("LONG")
	trino_KIND_VARIABLE   = trino_typeKind("VARIABLE")
)

type trino_typeArgument struct {
	// Kind determines if the typeSignature, namedTypeSignature, or long field has a value
	Kind  trino_typeKind  `json:"kind"`
	Value json.RawMessage `json:"value"`
	// typeSignature decoded from Value when Kind is TYPE
	typeSignature trino_typeSignature
	// namedTypeSignature decoded from Value when Kind is NAMED_TYPE
	namedTypeSignature trino_namedTypeSignature
	// long decoded from Value when Kind is LONG
	long int64
}

func trino_handleResponseError(status int, respErr trino_stmtError) error {
	switch respErr.ErrorName {
	case "":
		return nil
	case "USER_CANCELLED":
		return trino_ErrQueryCancelled
	default:
		return &trino_ErrQueryFailed{
			StatusCode: status,
			Reason:     &respErr,
		}
	}
}

func (qr *trino_driverRows) fetch() error {
	var qresp trino_queryResponse
	var err error
	for {
		select {
		case qresp = <-qr.stmt.queryResponses:
			if qresp.ID == "" {
				return io.EOF
			}
			err = qr.initColumns(&qresp)
			if err != nil {
				return err
			}
			qr.rowindex = 0
			qr.data = qresp.Data
			qr.rowsAffected = qresp.UpdateCount
			qr.scheduleProgressUpdate(qresp.ID, qresp.Stats)
			if len(qr.data) != 0 {
				return nil
			}
		case err = <-qr.stmt.errors:
			if err == nil {
				// Channel was closed, which means the statement
				// or rows were closed.
				err = io.EOF
			} else if err == context.Canceled {
				qr.Close()
			}
			qr.err = err
			return err
		}
	}
}

func trino_unmarshalArguments(signature *trino_typeSignature) error {
	for i, argument := range signature.Arguments {
		var payload interface{}
		switch argument.Kind {
		case trino_KIND_TYPE:
			payload = &(signature.Arguments[i].typeSignature)
		case trino_KIND_NAMED_TYPE:
			payload = &(signature.Arguments[i].namedTypeSignature)
		case trino_KIND_LONG:
			payload = &(signature.Arguments[i].long)
		}
		err := json.Unmarshal(argument.Value, payload)
		if err != nil {
			return err
		}
		switch argument.Kind {
		case trino_KIND_TYPE:
			err = trino_unmarshalArguments(&(signature.Arguments[i].typeSignature))
		case trino_KIND_NAMED_TYPE:
			err = trino_unmarshalArguments(&(signature.Arguments[i].namedTypeSignature.TypeSignature))
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (qr *trino_driverRows) initColumns(qresp *trino_queryResponse) error {
	if qr.columns != nil || len(qresp.Columns) == 0 {
		return nil
	}
	var err error
	for i := range qresp.Columns {
		err = trino_unmarshalArguments(&(qresp.Columns[i].TypeSignature))
		if err != nil {
			return fmt.Errorf("error decoding column type signature: %w", err)
		}
	}
	qr.columns = make([]string, len(qresp.Columns))
	qr.coltype = make([]*trino_typeConverter, len(qresp.Columns))
	for i, col := range qresp.Columns {
		err = trino_unmarshalArguments(&(qresp.Columns[i].TypeSignature))
		if err != nil {
			return fmt.Errorf("error decoding column type signature: %w", err)
		}
		qr.columns[i] = col.Name
		qr.coltype[i], err = trino_newTypeConverter(col.Type, col.TypeSignature)
		if err != nil {
			return err
		}
	}
	return nil
}

func (qr *trino_driverRows) scheduleProgressUpdate(id string, stats trino_stmtStats) {
	if qr.stmt.conn.progressUpdater == nil {
		return
	}

	qrStats := trino_QueryProgressInfo{
		QueryId:    id,
		QueryStats: stats,
	}
	currentTime := time.Now()
	diff := currentTime.Sub(qr.stmt.conn.progressUpdaterPeriod.LastCallbackTime)
	period := qr.stmt.conn.progressUpdaterPeriod.Period

	// Check if period has not passed yet AND if query state did not change
	if diff < period && qr.stmt.conn.progressUpdaterPeriod.LastQueryState == qrStats.QueryStats.State {
		return
	}

	select {
	case qr.statsCh <- qrStats:
	default:
		// ignore when can't send stats
	}
	qr.stmt.conn.progressUpdaterPeriod.LastCallbackTime = currentTime
	qr.stmt.conn.progressUpdaterPeriod.LastQueryState = qrStats.QueryStats.State
}

type trino_typeConverter struct {
	typeName   string
	parsedType []string
	scanType   reflect.Type
	precision  trino_optionalInt64
	scale      trino_optionalInt64
	size       trino_optionalInt64
}

type trino_optionalInt64 struct {
	value    int64
	hasValue bool
}

func trino_newOptionalInt64(value int64) trino_optionalInt64 {
	return trino_optionalInt64{value: value, hasValue: true}
}

func trino_newTypeConverter(typeName string, signature trino_typeSignature) (*trino_typeConverter, error) {
	result := &trino_typeConverter{
		typeName:   typeName,
		parsedType: trino_getNestedTypes([]string{}, signature),
	}
	var err error
	result.scanType, err = trino_getScanType(result.parsedType)
	if err != nil {
		return nil, err
	}
	switch signature.RawType {
	case "char", "varchar":
		if len(signature.Arguments) > 0 {
			if signature.Arguments[0].Kind != trino_KIND_LONG {
				return nil, trino_ErrInvalidResponseType
			}
			result.size = trino_newOptionalInt64(signature.Arguments[0].long)
		}
	case "decimal":
		if len(signature.Arguments) > 0 {
			if signature.Arguments[0].Kind != trino_KIND_LONG {
				return nil, trino_ErrInvalidResponseType
			}
			result.precision = trino_newOptionalInt64(signature.Arguments[0].long)
		}
		if len(signature.Arguments) > 1 {
			if signature.Arguments[1].Kind != trino_KIND_LONG {
				return nil, trino_ErrInvalidResponseType
			}
			result.scale = trino_newOptionalInt64(signature.Arguments[1].long)
		}
	case "time", "time with time zone", "timestamp", "timestamp with time zone":
		if len(signature.Arguments) > 0 {
			if signature.Arguments[0].Kind != trino_KIND_LONG {
				return nil, trino_ErrInvalidResponseType
			}
			result.precision = trino_newOptionalInt64(signature.Arguments[0].long)
		}
	}

	return result, nil
}

func trino_getNestedTypes(types []string, signature trino_typeSignature) []string {
	types = append(types, signature.RawType)
	if len(signature.Arguments) == 1 {
		switch signature.Arguments[0].Kind {
		case trino_KIND_TYPE:
			types = trino_getNestedTypes(types, signature.Arguments[0].typeSignature)
		case trino_KIND_NAMED_TYPE:
			types = trino_getNestedTypes(types, signature.Arguments[0].namedTypeSignature.TypeSignature)
		}
	}
	return types
}

func trino_getScanType(typeNames []string) (reflect.Type, error) {
	var v interface{}
	switch typeNames[0] {
	case "boolean":
		v = sql.NullBool{}
	case "json", "char", "varchar", "varbinary", "interval year to month", "interval day to second", "decimal", "ipaddress", "uuid", "unknown":
		v = sql.NullString{}
	case "tinyint", "smallint":
		v = sql.NullInt32{}
	case "integer":
		v = sql.NullInt32{}
	case "bigint":
		v = sql.NullInt64{}
	case "real", "double":
		v = sql.NullFloat64{}
	case "date", "time", "time with time zone", "timestamp", "timestamp with time zone":
		v = sql.NullTime{}
	case "map":
		v = trino_NullMap{}
	case "array":
		if len(typeNames) <= 1 {
			return nil, trino_ErrInvalidResponseType
		}
		switch typeNames[1] {
		case "boolean":
			v = trino_NullSliceBool{}
		case "json", "char", "varchar", "varbinary", "interval year to month", "interval day to second", "decimal", "ipaddress", "uuid", "unknown":
			v = trino_NullSliceString{}
		case "tinyint", "smallint", "integer", "bigint":
			v = trino_NullSliceInt64{}
		case "real", "double":
			v = trino_NullSliceFloat64{}
		case "date", "time", "time with time zone", "timestamp", "timestamp with time zone":
			v = trino_NullSliceTime{}
		case "map":
			v = trino_NullSliceMap{}
		case "array":
			if len(typeNames) <= 2 {
				return nil, trino_ErrInvalidResponseType
			}
			switch typeNames[2] {
			case "boolean":
				v = trino_NullSlice2Bool{}
			case "json", "char", "varchar", "varbinary", "interval year to month", "interval day to second", "decimal", "ipaddress", "uuid", "unknown":
				v = trino_NullSlice2String{}
			case "tinyint", "smallint", "integer", "bigint":
				v = trino_NullSlice2Int64{}
			case "real", "double":
				v = trino_NullSlice2Float64{}
			case "date", "time", "time with time zone", "timestamp", "timestamp with time zone":
				v = trino_NullSlice2Time{}
			case "map":
				v = trino_NullSlice2Map{}
			case "array":
				if len(typeNames) <= 3 {
					return nil, trino_ErrInvalidResponseType
				}
				switch typeNames[3] {
				case "boolean":
					v = trino_NullSlice3Bool{}
				case "json", "char", "varchar", "varbinary", "interval year to month", "interval day to second", "decimal", "ipaddress", "uuid", "unknown":
					v = trino_NullSlice3String{}
				case "tinyint", "smallint", "integer", "bigint":
					v = trino_NullSlice3Int64{}
				case "real", "double":
					v = trino_NullSlice3Float64{}
				case "date", "time", "time with time zone", "timestamp", "timestamp with time zone":
					v = trino_NullSlice3Time{}
				case "map":
					v = trino_NullSlice3Map{}
				}
				// if this is a 4 or more dimensional array, scan type will be an empty interface
			}
		}
	}
	if v == nil {
		return reflect.TypeOf(new(interface{})).Elem(), nil
	}
	return reflect.TypeOf(v), nil
}

// ConvertValue implements the driver.ValueConverter interface.
func (c *trino_typeConverter) ConvertValue(v interface{}) (driver.Value, error) {
	switch c.parsedType[0] {
	case "boolean":
		vv, err := trino_scanNullBool(v)
		if !vv.Valid {
			return nil, err
		}
		return vv.Bool, err
	case "json", "char", "varchar", "varbinary", "interval year to month", "interval day to second", "decimal", "ipaddress", "uuid", "unknown":
		vv, err := trino_scanNullString(v)
		if !vv.Valid {
			return nil, err
		}
		return vv.String, err
	case "tinyint", "smallint", "integer", "bigint":
		vv, err := trino_scanNullInt64(v)
		if !vv.Valid {
			return nil, err
		}
		return vv.Int64, err
	case "real", "double":
		vv, err := trino_scanNullFloat64(v)
		if !vv.Valid {
			return nil, err
		}
		return vv.Float64, err
	case "date", "time", "time with time zone", "timestamp", "timestamp with time zone":
		vv, err := trino_scanNullTime(v)
		if !vv.Valid {
			return nil, err
		}
		return vv.Time, err
	case "map":
		if err := trino_validateMap(v); err != nil {
			return nil, err
		}
		return v, nil
	case "array":
		if err := trino_validateSlice(v); err != nil {
			return nil, err
		}
		return v, nil
	case "row":
		if err := trino_validateSlice(v); err != nil {
			return nil, err
		}
		return v, nil
	default:
		return nil, fmt.Errorf("type not supported: %q", c.typeName)
	}
}

func trino_validateMap(v interface{}) error {
	if v == nil {
		return nil
	}
	if _, ok := v.(map[string]interface{}); !ok {
		return fmt.Errorf("cannot convert %v (%T) to map", v, v)
	}
	return nil
}

func trino_validateSlice(v interface{}) error {
	if v == nil {
		return nil
	}
	if _, ok := v.([]interface{}); !ok {
		return fmt.Errorf("cannot convert %v (%T) to slice", v, v)
	}
	return nil
}

func trino_scanNullBool(v interface{}) (sql.NullBool, error) {
	if v == nil {
		return sql.NullBool{}, nil
	}
	vv, ok := v.(bool)
	if !ok {
		return sql.NullBool{},
			fmt.Errorf("cannot convert %v (%T) to bool", v, v)
	}
	return sql.NullBool{Valid: true, Bool: vv}, nil
}

// NullSliceBool represents a slice of bool that may be null.
type trino_NullSliceBool struct {
	SliceBool []sql.NullBool
	Valid     bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceBool) Scan(value interface{}) error {
	if value == nil {
		s.SliceBool, s.Valid = []sql.NullBool{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []bool", value, value)
	}
	slice := make([]sql.NullBool, len(vs))
	for i := range vs {
		v, err := trino_scanNullBool(vs[i])
		if err != nil {
			return err
		}
		slice[i] = v
	}
	s.SliceBool = slice
	s.Valid = true
	return nil
}

// NullSlice2Bool represents a two-dimensional slice of bool that may be null.
type trino_NullSlice2Bool struct {
	Slice2Bool [][]sql.NullBool
	Valid      bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2Bool) Scan(value interface{}) error {
	if value == nil {
		s.Slice2Bool, s.Valid = [][]sql.NullBool{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]bool", value, value)
	}
	slice := make([][]sql.NullBool, len(vs))
	for i := range vs {
		var ss trino_NullSliceBool
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceBool
	}
	s.Slice2Bool = slice
	s.Valid = true
	return nil
}

// NullSlice3Bool implements a three-dimensional slice of bool that may be null.
type trino_NullSlice3Bool struct {
	Slice3Bool [][][]sql.NullBool
	Valid      bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3Bool) Scan(value interface{}) error {
	if value == nil {
		s.Slice3Bool, s.Valid = [][][]sql.NullBool{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]bool", value, value)
	}
	slice := make([][][]sql.NullBool, len(vs))
	for i := range vs {
		var ss trino_NullSlice2Bool
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2Bool
	}
	s.Slice3Bool = slice
	s.Valid = true
	return nil
}

func trino_scanNullString(v interface{}) (sql.NullString, error) {
	if v == nil {
		return sql.NullString{}, nil
	}
	vv, ok := v.(string)
	if !ok {
		return sql.NullString{},
			fmt.Errorf("cannot convert %v (%T) to string", v, v)
	}
	return sql.NullString{Valid: true, String: vv}, nil
}

// NullSliceString represents a slice of string that may be null.
type trino_NullSliceString struct {
	SliceString []sql.NullString
	Valid       bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceString) Scan(value interface{}) error {
	if value == nil {
		s.SliceString, s.Valid = []sql.NullString{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []string", value, value)
	}
	slice := make([]sql.NullString, len(vs))
	for i := range vs {
		v, err := trino_scanNullString(vs[i])
		if err != nil {
			return err
		}
		slice[i] = v
	}
	s.SliceString = slice
	s.Valid = true
	return nil
}

// NullSlice2String represents a two-dimensional slice of string that may be null.
type trino_NullSlice2String struct {
	Slice2String [][]sql.NullString
	Valid        bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2String) Scan(value interface{}) error {
	if value == nil {
		s.Slice2String, s.Valid = [][]sql.NullString{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]string", value, value)
	}
	slice := make([][]sql.NullString, len(vs))
	for i := range vs {
		var ss trino_NullSliceString
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceString
	}
	s.Slice2String = slice
	s.Valid = true
	return nil
}

// NullSlice3String implements a three-dimensional slice of string that may be null.
type trino_NullSlice3String struct {
	Slice3String [][][]sql.NullString
	Valid        bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3String) Scan(value interface{}) error {
	if value == nil {
		s.Slice3String, s.Valid = [][][]sql.NullString{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]string", value, value)
	}
	slice := make([][][]sql.NullString, len(vs))
	for i := range vs {
		var ss trino_NullSlice2String
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2String
	}
	s.Slice3String = slice
	s.Valid = true
	return nil
}

func trino_scanNullInt64(v interface{}) (sql.NullInt64, error) {
	if v == nil {
		return sql.NullInt64{}, nil
	}
	vNumber, ok := v.(json.Number)
	if !ok {
		return sql.NullInt64{},
			fmt.Errorf("cannot convert %v (%T) to int64", v, v)
	}
	vv, err := vNumber.Int64()
	if err != nil {
		return sql.NullInt64{},
			fmt.Errorf("cannot convert %v (%T) to int64", v, v)
	}
	return sql.NullInt64{Valid: true, Int64: vv}, nil
}

// NullSliceInt64 represents a slice of int64 that may be null.
type trino_NullSliceInt64 struct {
	SliceInt64 []sql.NullInt64
	Valid      bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceInt64) Scan(value interface{}) error {
	if value == nil {
		s.SliceInt64, s.Valid = []sql.NullInt64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []int64", value, value)
	}
	slice := make([]sql.NullInt64, len(vs))
	for i := range vs {
		v, err := trino_scanNullInt64(vs[i])
		if err != nil {
			return err
		}
		slice[i] = v
	}
	s.SliceInt64 = slice
	s.Valid = true
	return nil
}

// NullSlice2Int64 represents a two-dimensional slice of int64 that may be null.
type trino_NullSlice2Int64 struct {
	Slice2Int64 [][]sql.NullInt64
	Valid       bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2Int64) Scan(value interface{}) error {
	if value == nil {
		s.Slice2Int64, s.Valid = [][]sql.NullInt64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]int64", value, value)
	}
	slice := make([][]sql.NullInt64, len(vs))
	for i := range vs {
		var ss trino_NullSliceInt64
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceInt64
	}
	s.Slice2Int64 = slice
	s.Valid = true
	return nil
}

// NullSlice3Int64 implements a three-dimensional slice of int64 that may be null.
type trino_NullSlice3Int64 struct {
	Slice3Int64 [][][]sql.NullInt64
	Valid       bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3Int64) Scan(value interface{}) error {
	if value == nil {
		s.Slice3Int64, s.Valid = [][][]sql.NullInt64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]int64", value, value)
	}
	slice := make([][][]sql.NullInt64, len(vs))
	for i := range vs {
		var ss trino_NullSlice2Int64
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2Int64
	}
	s.Slice3Int64 = slice
	s.Valid = true
	return nil
}

func trino_scanNullFloat64(v interface{}) (sql.NullFloat64, error) {
	if v == nil {
		return sql.NullFloat64{}, nil
	}
	vNumber, ok := v.(json.Number)
	if ok {
		vFloat, err := vNumber.Float64()
		if err != nil {
			return sql.NullFloat64{}, fmt.Errorf("cannot convert %v (%T) to float64: %w", vNumber, vNumber, err)
		}
		return sql.NullFloat64{Valid: true, Float64: vFloat}, nil
	}
	switch v {
	case "NaN":
		return sql.NullFloat64{Valid: true, Float64: math.NaN()}, nil
	case "Infinity":
		return sql.NullFloat64{Valid: true, Float64: math.Inf(+1)}, nil
	case "-Infinity":
		return sql.NullFloat64{Valid: true, Float64: math.Inf(-1)}, nil
	default:
		vString, ok := v.(string)
		if !ok {
			return sql.NullFloat64{}, fmt.Errorf("cannot convert %v (%T) to float64", v, v)
		}
		vFloat, err := strconv.ParseFloat(vString, 64)
		if err != nil {
			return sql.NullFloat64{}, fmt.Errorf("cannot convert %v (%T) to float64: %w", v, v, err)
		}
		return sql.NullFloat64{Valid: true, Float64: vFloat}, nil
	}
}

// NullSliceFloat64 represents a slice of float64 that may be null.
type trino_NullSliceFloat64 struct {
	SliceFloat64 []sql.NullFloat64
	Valid        bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceFloat64) Scan(value interface{}) error {
	if value == nil {
		s.SliceFloat64, s.Valid = []sql.NullFloat64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []float64", value, value)
	}
	slice := make([]sql.NullFloat64, len(vs))
	for i := range vs {
		v, err := trino_scanNullFloat64(vs[i])
		if err != nil {
			return err
		}
		slice[i] = v
	}
	s.SliceFloat64 = slice
	s.Valid = true
	return nil
}

// NullSlice2Float64 represents a two-dimensional slice of float64 that may be null.
type trino_NullSlice2Float64 struct {
	Slice2Float64 [][]sql.NullFloat64
	Valid         bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2Float64) Scan(value interface{}) error {
	if value == nil {
		s.Slice2Float64, s.Valid = [][]sql.NullFloat64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]float64", value, value)
	}
	slice := make([][]sql.NullFloat64, len(vs))
	for i := range vs {
		var ss trino_NullSliceFloat64
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceFloat64
	}
	s.Slice2Float64 = slice
	s.Valid = true
	return nil
}

// NullSlice3Float64 represents a three-dimensional slice of float64 that may be null.
type trino_NullSlice3Float64 struct {
	Slice3Float64 [][][]sql.NullFloat64
	Valid         bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3Float64) Scan(value interface{}) error {
	if value == nil {
		s.Slice3Float64, s.Valid = [][][]sql.NullFloat64{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]float64", value, value)
	}
	slice := make([][][]sql.NullFloat64, len(vs))
	for i := range vs {
		var ss trino_NullSlice2Float64
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2Float64
	}
	s.Slice3Float64 = slice
	s.Valid = true
	return nil
}

// Layout for time and timestamp WITHOUT time zone.
// Trino can support up to 12 digits sub second precision, but Go only 9.
// (Requires X-Trino-Client-Capabilities: PARAMETRIC_DATETIME)
var trino_timeLayouts = []string{
	"2006-01-02",
	"15:04:05.999999999",
	"2006-01-02 15:04:05.999999999",
}

// Layout for time and timestamp WITH time zone.
// Trino can support up to 12 digits sub second precision, but Go only 9.
// (Requires X-Trino-Client-Capabilities: PARAMETRIC_DATETIME)
var trino_timeLayoutsTZ = []string{
	"15:04:05.999999999 -07:00",
	"2006-01-02 15:04:05.999999999 -07:00",
}

func trino_scanNullTime(v interface{}) (trino_NullTime, error) {
	if v == nil {
		return trino_NullTime{}, nil
	}
	vv, ok := v.(string)
	if !ok {
		return trino_NullTime{}, fmt.Errorf("cannot convert %v (%T) to time string", v, v)
	}
	vparts := strings.Split(vv, " ")
	if len(vparts) > 1 && !unicode.IsDigit(rune(vparts[len(vparts)-1][0])) {
		return trino_parseNullTimeWithLocation(vv)
	}
	// Time literals may not have spaces before the timezone.
	if strings.ContainsRune(vv, '+') {
		return trino_parseNullTimeWithLocation(strings.Replace(vv, "+", " +", 1))
	}
	hyphenCount := strings.Count(vv, "-")
	// We need to ensure we don't treat the hyphens in dates as the minus offset sign.
	// So if there's only one hyphen or more than 2, we have a negative offset.
	if hyphenCount == 1 || hyphenCount > 2 {
		// We add a space before the last hyphen to parse properly.
		i := strings.LastIndex(vv, "-")
		timestamp := vv[:i] + strings.Replace(vv[i:], "-", " -", 1)
		return trino_parseNullTimeWithLocation(timestamp)
	}
	return trino_parseNullTime(vv)
}

func trino_parseNullTime(v string) (trino_NullTime, error) {
	var t time.Time
	var err error
	for _, layout := range trino_timeLayouts {
		t, err = time.ParseInLocation(layout, v, time.Local)
		if err == nil {
			return trino_NullTime{Valid: true, Time: t}, nil
		}
	}
	return trino_NullTime{}, err
}

func trino_parseNullTimeWithLocation(v string) (trino_NullTime, error) {
	idx := strings.LastIndex(v, " ")
	if idx == -1 {
		return trino_NullTime{}, fmt.Errorf("cannot convert %v (%T) to time+zone", v, v)
	}
	stamp, location := v[:idx], v[idx+1:]
	var t time.Time
	var err error
	// Try offset timezones.
	if strings.HasPrefix(location, "+") || strings.HasPrefix(location, "-") {
		for _, layout := range trino_timeLayoutsTZ {
			t, err = time.Parse(layout, v)
			if err == nil {
				return trino_NullTime{Valid: true, Time: t}, nil
			}
		}
		return trino_NullTime{}, err
	}
	loc, err := time.LoadLocation(location)
	// Not a named location.
	if err != nil {
		return trino_NullTime{}, fmt.Errorf("cannot load timezone %q: %v", location, err)
	}

	for _, layout := range trino_timeLayouts {
		t, err = time.ParseInLocation(layout, stamp, loc)
		if err == nil {
			return trino_NullTime{Valid: true, Time: t}, nil
		}
	}
	return trino_NullTime{}, err
}

// NullTime represents a time.Time value that can be null.
// The NullTime supports Trino's Date, Time and Timestamp data types,
// with or without time zone.
type trino_NullTime struct {
	Time  time.Time
	Valid bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullTime) Scan(value interface{}) error {
	if value == nil {
		s.Time, s.Valid = time.Time{}, false
		return nil
	}
	switch t := value.(type) {
	case time.Time:
		s.Time, s.Valid = t, true
	case trino_NullTime:
		*s = t
	}
	return nil
}

// NullSliceTime represents a slice of time.Time that may be null.
type trino_NullSliceTime struct {
	SliceTime []trino_NullTime
	Valid     bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceTime) Scan(value interface{}) error {
	if value == nil {
		s.SliceTime, s.Valid = []trino_NullTime{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []time.Time", value, value)
	}
	slice := make([]trino_NullTime, len(vs))
	for i := range vs {
		v, err := trino_scanNullTime(vs[i])
		if err != nil {
			return err
		}
		slice[i] = v
	}
	s.SliceTime = slice
	s.Valid = true
	return nil
}

// NullSlice2Time represents a two-dimensional slice of time.Time that may be null.
type trino_NullSlice2Time struct {
	Slice2Time [][]trino_NullTime
	Valid      bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2Time) Scan(value interface{}) error {
	if value == nil {
		s.Slice2Time, s.Valid = [][]trino_NullTime{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]time.Time", value, value)
	}
	slice := make([][]trino_NullTime, len(vs))
	for i := range vs {
		var ss trino_NullSliceTime
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceTime
	}
	s.Slice2Time = slice
	s.Valid = true
	return nil
}

// NullSlice3Time represents a three-dimensional slice of time.Time that may be null.
type trino_NullSlice3Time struct {
	Slice3Time [][][]trino_NullTime
	Valid      bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3Time) Scan(value interface{}) error {
	if value == nil {
		s.Slice3Time, s.Valid = [][][]trino_NullTime{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]time.Time", value, value)
	}
	slice := make([][][]trino_NullTime, len(vs))
	for i := range vs {
		var ss trino_NullSlice2Time
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2Time
	}
	s.Slice3Time = slice
	s.Valid = true
	return nil
}

// NullMap represents a map type that may be null.
type trino_NullMap struct {
	Map   map[string]interface{}
	Valid bool
}

// Scan implements the sql.Scanner interface.
func (m *trino_NullMap) Scan(v interface{}) error {
	if v == nil {
		m.Map, m.Valid = map[string]interface{}{}, false
		return nil
	}
	m.Map, m.Valid = v.(map[string]interface{})
	return nil
}

// NullSliceMap represents a slice of NullMap that may be null.
type trino_NullSliceMap struct {
	SliceMap []trino_NullMap
	Valid    bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSliceMap) Scan(value interface{}) error {
	if value == nil {
		s.SliceMap, s.Valid = []trino_NullMap{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to []NullMap", value, value)
	}
	slice := make([]trino_NullMap, len(vs))
	for i := range vs {
		if err := trino_validateMap(vs[i]); err != nil {
			return fmt.Errorf("cannot convert %v (%T) to []NullMap", value, value)
		}
		m := trino_NullMap{}
		// this scan can never fail
		_ = m.Scan(vs[i])
		slice[i] = m
	}
	s.SliceMap = slice
	s.Valid = true
	return nil
}

// NullSlice2Map represents a two-dimensional slice of NullMap that may be null.
type trino_NullSlice2Map struct {
	Slice2Map [][]trino_NullMap
	Valid     bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice2Map) Scan(value interface{}) error {
	if value == nil {
		s.Slice2Map, s.Valid = [][]trino_NullMap{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][]NullMap", value, value)
	}
	slice := make([][]trino_NullMap, len(vs))
	for i := range vs {
		var ss trino_NullSliceMap
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.SliceMap
	}
	s.Slice2Map = slice
	s.Valid = true
	return nil
}

// NullSlice3Map represents a three-dimensional slice of NullMap that may be null.
type trino_NullSlice3Map struct {
	Slice3Map [][][]trino_NullMap
	Valid     bool
}

// Scan implements the sql.Scanner interface.
func (s *trino_NullSlice3Map) Scan(value interface{}) error {
	if value == nil {
		s.Slice3Map, s.Valid = [][][]trino_NullMap{}, false
		return nil
	}
	vs, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("trino: cannot convert %v (%T) to [][][]NullMap", value, value)
	}
	slice := make([][][]trino_NullMap, len(vs))
	for i := range vs {
		var ss trino_NullSlice2Map
		if err := ss.Scan(vs[i]); err != nil {
			return err
		}
		slice[i] = ss.Slice2Map
	}
	s.Slice3Map = slice
	s.Valid = true
	return nil
}

type trino_QueryProgressInfo struct {
	QueryId    string
	QueryStats trino_stmtStats
}

type trino_queryProgressCallbackPeriod struct {
	Period           time.Duration
	LastCallbackTime time.Time
	LastQueryState   string
}

type trino_ProgressUpdater interface {
	// Update the query progress, immediately when the query starts, when receiving data, and once when the query is finished.
	Update(trino_QueryProgressInfo)
}
